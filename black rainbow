// ==UserScript==
// @name         Black Rainbow
// @namespace    http://tampermonkey.net/
// @description  try to take over the world!
// @version      final version
// @author       Bl4cky
// @match        *://*.moomoo.io/*
// @require      https://cdn.jsdelivr.net/npm/msgpack-lite@0.1.26/dist/msgpack.min.js
// @icon         https://i.pinimg.com/originals/f8/7a/d3/f87ad32360e70eaf0b8f7ae9b5ed2b67.gif
// @grant        none
// @run-at      document-start
// ==/UserScript==
function remValue(name) {
    return localStorage.removeItem(name);
};

function getValue(name) {
    return localStorage.getItem(name);
    return null;
};

function setValue(name, data) {
    return localStorage.setItem(name, data);
};

function createHook(target, prop, callback) {
    const symbol = Symbol(prop);
    Object.defineProperty(target, prop, {
        get() {
            return this[symbol];
        },
        set(value) {
            callback(this, symbol, value);
        },
        configurable: true,
    })
}
createHook(Object.prototype, "deathFadeout", function(that, symbol, value) {
    delete Object.prototype.deathFadeout;
    that.deathFadeout = 0;
    console.log("Removed death screen for you");
});
var vultrClient = {};
createHook(Object.prototype, "regionInfo", function(that, symbol, value) {
    //To Client Dont Bug:
    delete Object.prototype.regionInfo;
    that.regionInfo = value;

    // Hook Vult Client:
    vultrClient = that;
});
setValue("moofoll", 1);
window.ws = null;
getValue("clearedStorage") == undefined && setValue("clearedStorage", false);
if (getValue("clearedStorage") == "false") {
    let clear = window.confirm("Would you like to clear storage?");
    if (clear == true) {
        localStorage.clear();
    }
    setValue("clearedStorage", true);
}
var pushToTick = [];
!getValue("textures") && setValue("textures", JSON.stringify({}));
!getValue("settings") && setValue("settings", JSON.stringify({}));
!getValue("modules") && setValue("modules", JSON.stringify({}));
var textures = {};
var settings = {};
var __webpack_module_cache__ = {};
try {
    textures = JSON.parse(getValue("textures"));
    settings = JSON.parse(getValue("settings"));
    __webpack_module_cache__ = JSON.parse(getValue("modules"));
} catch(e){

}

function __webpack_require__(moduleId) {
    var cachedModule = __webpack_module_cache__[moduleId];
    if (cachedModule !== undefined) {
        return cachedModule.exports;
    }
    var module = __webpack_module_cache__[moduleId] = {
        id: moduleId,
        loaded: false,
        exports: {},
    };
    __webpack_modules__[moduleId](module);
    getValue("modules")[moduleId] = module;
    module.loaded = true;
    return module.exports;
}
var __webpack_modules__ = ({
    "./script/src/js/libs/antiCheatCalculator.js": (function(module) {
        module.exports = {
            perSecond: {
                current: 0,
                maximum: 120,
                resetC: 0,
                resetA: 9,
            },
            perMinute: {
                current: 0,
                maximum: 56e2,
                resetC: 0,
                resetA: 54e2,
            },
            sentToServer: function() {
                ["perSecond", "perMinute"].forEach(each => module.exports[each].current++);
            },
            resetCalculator: function() {
                ["perSecond", "perMinute"].forEach(each => ++module.exports[each].resetC % module.exports[each].resetA == 0 && (module
                                                                                                                                .exports[each].current = 0));
            },
        }
    }),
    "./script/src/js/libs/modernizr.js": (function(module) {
        module.exports.run = function() {
            ! function(e, n, s) {
                function o(e, n) {
                    return typeof e === n
                }

                function a() {
                    var e, n, s, a, t, f, l;
                    for (var c in r) {
                        if (r.hasOwnProperty(c)) {
                            e = [];
                            n = r[c];
                            if (n.name && (e.push(n.name.toLowerCase()), n.options && n.options.aliases && n.options.aliases.length)) {
                                for (s = 0; s < n.options.aliases.length; s++) e.push(n.options.aliases[s].toLowerCase());
                            }
                            for (a = o(n.fn, "function") ? n.fn() : n.fn, t = 0; t < e.length; t++) {
                                f = e[t];
                                l = f.split(".");
                                1 === l.length ? Modernizr[l[0]] = a : (!Modernizr[l[0]] || Modernizr[l[0]] instanceof Boolean || (
                                    Modernizr[l[0]] = new Boolean(Modernizr[l[0]])), Modernizr[l[0]][l[1]] = a);
                                i.push((a ? "" : "no-") + l.join("-"));
                            }
                        }
                    }
                }

                function t(e) {
                    var n = l.className,
                        s = Modernizr._config.classPrefix || "";
                    c && (n = n.baseVal);
                    if (Modernizr._config.enableJSClass) {
                        var o = new RegExp("(^|\\s)" + s + "no-js(\\s|$)");
                        n = n.replace(o, "$1" + s + "js$2")
                    }
                    Modernizr._config.enableClasses && (n += " " + s + e.join(" " + s), c ? l.className.baseVal = n : l.className = n)
                }
                var i = [],
                    r = [],
                    f = {
                        _version: "3.5.0",
                        _config: {
                            classPrefix: "",
                            enableClasses: !0,
                            enableJSClass: !0,
                            usePrefixes: !0
                        },
                        _q: [],
                        on: function(e, n) {
                            var s = this;
                            setTimeout(function() {
                                n(s[e])
                            }, 0)
                        },
                        addTest: function(e, n, s) {
                            r.push({
                                name: e,
                                fn: n,
                                options: s
                            })
                        },
                        addAsyncTest: function(e) {
                            r.push({
                                name: null,
                                fn: e
                            })
                        }
                    },
                    Modernizr = function() { };
                Modernizr.prototype = f;
                Modernizr = new Modernizr;
                var l = n.documentElement,
                    c = "svg" === l.nodeName.toLowerCase();
                Modernizr.addTest("passiveeventlisteners", function() {
                    var n = !1;
                    try {
                        var s = Object.defineProperty({}, "passive", {
                            get: function() {
                                n = !0
                            }
                        });
                        e.addEventListener("test", null, s)
                    } catch (o) { }
                    return n
                });
                a();
                t(i);
                delete f.addTest;
                delete f.addAsyncTest;
                for (var u = 0; u < Modernizr._q.length; u++) Modernizr._q[u]();
                e.Modernizr = Modernizr
            }(window, document);
        };
    }),
    "./script/src/js/config.js": (function(module) {
        module.exports.maxScreenWidth = 1920;
        module.exports.maxScreenHeight = 1080;

        // SERVER:
        module.exports.serverUpdateRate = 9;
        module.exports.maxPlayers = 40;
        module.exports.maxPlayersHard = module.exports.maxPlayers + 10;
        module.exports.collisionDepth = 6;
        module.exports.minimapRate = 3000;

        // COLLISIONS:
        module.exports.colGrid = 10;

        // CLIENT:
        module.exports.clientSendRate = 5;

        // UI:
        module.exports.healthBarWidth = 50;
        module.exports.healthBarPad = 4.5;
        module.exports.iconPadding = 15;
        module.exports.iconPad = 0.9;
        module.exports.deathFadeout = 3000;
        module.exports.crownIconScale = 60;
        module.exports.crownPad = 35;

        // CHAT:
        module.exports.chatCountdown = 3000;
        module.exports.chatCooldown = 500;

        // SANDBOX:
        module.exports.inSandbox = location.href.match("sandbox")?.length ? true : false;

        // PLAYER:
        module.exports.maxAge = 100;
        module.exports.gatherAngle = Math.PI / 2.6;
        module.exports.gatherWiggle = 10;
        module.exports.hitReturnRatio = 0.25;
        module.exports.hitAngle = Math.PI / 2;
        module.exports.playerScale = 35;
        module.exports.playerSpeed = 0.0016;
        module.exports.playerDecel = 0.993;
        module.exports.nameY = 34;

        // CUSTOMIZATION:
        module.exports.skinColors = ["#bf8f54", "#cbb091", "#896c4b",
                                     "#fadadc", "#ececec", "#c37373", "#4c4c4c", "#ecaff7", "#738cc3",
                                     "#8bc373"
                                    ];

        // ANIMALS:
        module.exports.animalCount = 7;
        module.exports.aiTurnRandom = 0.06;
        module.exports.cowNames = ["Sid", "Steph", "Bmoe", "Romn", "Jononthecool", "Fiona", "Vince", "Nathan", "Nick", "Flappy", "Ronald",
                                   "Otis", "Pepe", "Mc Donald", "Theo", "Fabz", "Oliver", "Jeff", "Jimmy", "Helena", "Reaper",
                                   "Ben", "Alan", "Naomi", "XYZ", "Clever", "Jeremy", "Mike", "Destined", "Stallion", "Allison", "Meaty", "Sophia", "Vaja", "Joey",
                                   "Pendy", "Murdoch", "Theo", "Jared", "July", "Sonia", "Mel", "Dexter", "Quinn", "Milky"
                                  ];

        // WEAPONS:
        module.exports.shieldAngle = Math.PI / 3;
        module.exports.weaponVariants = [{
            id: 0,
            src: "",
            xp: 0,
            val: 1
        }, {
            id: 1,
            src: "_g",
            xp: 3000,
            val: 1.1
        }, {
            id: 2,
            src: "_d",
            xp: 7000,
            val: 1.18
        }, {
            id: 3,
            src: "_r",
            poison: true,
            xp: 12000,
            val: 1.18
        }];
        module.exports.fetchVariant = function(player) {
            var tmpXP = player.weaponXP[player.weaponIndex] || 0;
            for (var i = module.exports.weaponVariants.length - 1; i >= 0; --i) {
                if (tmpXP >= module.exports.weaponVariants[i].xp) return module.exports.weaponVariants[i];
            }
        };

        // NATURE:
        module.exports.resourceTypes = ["wood", "food", "stone", "points"];
        module.exports.areaCount = 7;
        module.exports.treesPerArea = 9;
        module.exports.bushesPerArea = 3;
        module.exports.totalRocks = 32;
        module.exports.goldOres = 7;
        module.exports.riverWidth = 724;
        module.exports.riverPadding = 114;
        module.exports.waterCurrent = 0.0011;
        module.exports.waveSpeed = 0.0001;
        module.exports.waveMax = 1.3;
        module.exports.treeScales = [150, 160, 165, 175];
        module.exports.bushScales = [80, 85, 95];
        module.exports.rockScales = [80, 85, 90];

        // BIOME DATA:
        module.exports.snowBiomeTop = 2400;
        module.exports.snowSpeed = 0.75;

        // DATA:
        module.exports.maxNameLength = 15;

        // MAP:
        module.exports.mapScale = 14400;
        module.exports.mapPingScale = 40;
        module.exports.mapPingTime = 2200;
    }),
    "./script/src/js/libs/utils.js": (function(module) {
        // MATH UTILS:
        var mathCOS = Math.cos;
        var mathSIN = Math.sin;
        var mathPOW = Math.pow;
        var mathSQRT = Math.sqrt;
        var mathABS = Math.abs;
        var mathATAN2 = Math.atan2;
        var mathPI = Math.PI;

        // GLOBAL UTILS:
        module.exports.toRad = function(angle) {
            return angle / 180 * Math.PI;
        };
        module.exports.toDeg = function(angle) {
            return angle * 180 / Math.PI;
        };
        module.exports.randInt = function(min, max) {
            return Math.floor(Math.random() * (max - min + 1)) + min;
        };
        module.exports.randFloat = function(min, max) {
            return Math.random() * (max - min + 1) + min;
        };
        module.exports.lerp = function(value1, value2, amount) {
            return value1 + (value2 - value1) * amount;
        };
        module.exports.decel = function(val, cel) {
            if (val > 0) val = Math.max(0, val - cel);
            else if (val < 0) val = Math.min(0, val + cel);
            return val;
        };
        module.exports.getDistance = function(x1, y1, x2, y2) {
            return mathSQRT((x2 -= x1) * x2 + (y2 -= y1) * y2);
        };
        module.exports.getDirection = function(x1, y1, x2, y2) {
            return mathATAN2(y1 - y2, x1 - x2);
        };
        module.exports.getAngleDist = function(a, b) {
            var p = mathABS(b - a) % (mathPI * 2);
            return (p > mathPI ? (mathPI * 2) - p : p);
        };
        module.exports.isNumber = function(n) {
            return (typeof n == "number" && !isNaN(n) && isFinite(n));
        };
        module.exports.isString = function(s) {
            return (s && typeof s == "string");
        };
        module.exports.numberFormat = function(num) {
            let formats = [
                [1e3, "k"],
                [1e6, "m"],
                [1e9, "b"],
                [1e12, "t"],
                [1e15, "q"],
            ];
            for (let i = 0; i < formats; i++) {
                let b;
                let a = [formats[i], (b = formats[i + 1]) ? b[0] : Infinity];
                return num >= a[0][0] && num < a[1] ? (num / a[0][0]).toFixed(1) + a[0][1] : num;
            }
        };
        module.exports.capitalizeFirst = function(string) {
            return string.charAt(0).toUpperCase() + string.slice(1);
        };
        module.exports.fixTo = function(n, v) {
            return parseFloat(n.toFixed(v));
        };
        module.exports.sortByPoints = function(a, b) {
            return parseFloat(b.points) - parseFloat(a.points);
        };
        module.exports.lineInRect = function(recX, recY, recX2, recY2, x1, y1, x2, y2) {
            var minX = x1;
            var maxX = x2;
            if (x1 > x2) {
                minX = x2;
                maxX = x1;
            }
            if (maxX > recX2) maxX = recX2;
            if (minX < recX) minX = recX;
            if (minX > maxX) return false;
            var minY = y1;
            var maxY = y2;
            var dx = x2 - x1;
            if (Math.abs(dx) > 0.0000001) {
                var a = (y2 - y1) / dx;
                var b = y1 - a * x1;
                minY = a * minX + b;
                maxY = a * maxX + b;
            }
            if (minY > maxY) {
                var tmp = maxY;
                maxY = minY;
                minY = tmp;
            }
            if (maxY > recY2) maxY = recY2;
            if (minY < recY) minY = recY;
            if (minY > maxY) return false;
            return true;
        };
        module.exports.containsPoint = function(element, x, y) {
            var bounds = element.getBoundingClientRect();
            var left = bounds.left + window.scrollX;
            var top = bounds.top + window.scrollY;
            var width = bounds.width;
            var height = bounds.height;

            var insideHorizontal = x > left && x < left + width;
            var insideVertical = y > top && y < top + height;
            return insideHorizontal && insideVertical;
        };
        module.exports.mousifyTouchEvent = function(event) {
            var touch = event.changedTouches[0];
            event.screenX = touch.screenX;
            event.screenY = touch.screenY;
            event.clientX = touch.clientX;
            event.clientY = touch.clientY;
            event.pageX = touch.pageX;
            event.pageY = touch.pageY;
        };
        module.exports.hookTouchEvents = function(element, skipPrevent) {
            var preventDefault = !skipPrevent;
            var isHovering = false;
            // var passive = window.Modernizr.passiveeventlisteners ? {passive: true} : false;
            var passive = false;
            element.addEventListener("touchstart", module.exports.checkTrusted(touchStart), passive);
            element.addEventListener("touchmove", module.exports.checkTrusted(touchMove), passive);
            element.addEventListener("touchend", module.exports.checkTrusted(touchEnd), passive);
            element.addEventListener("touchcancel", module.exports.checkTrusted(touchEnd), passive);
            element.addEventListener("touchleave", module.exports.checkTrusted(touchEnd), passive);

            function touchStart(e) {
                module.exports.mousifyTouchEvent(e);
                window.setUsingTouch(true);
                if (preventDefault) {
                    e.preventDefault();
                    e.stopPropagation();
                }
                if (element.onmouseover) element.onmouseover(e);
                isHovering = true;
            }

            function touchMove(e) {
                module.exports.mousifyTouchEvent(e);
                window.setUsingTouch(true);
                if (preventDefault) {
                    e.preventDefault();
                    e.stopPropagation();
                }
                if (module.exports.containsPoint(element, e.pageX, e.pageY)) {
                    if (!isHovering) {
                        if (element.onmouseover) element.onmouseover(e);
                        isHovering = true;
                    }
                } else {
                    if (isHovering) {
                        if (element.onmouseout) element.onmouseout(e);
                        isHovering = false;
                    }
                }
            }

            function touchEnd(e) {
                module.exports.mousifyTouchEvent(e);
                window.setUsingTouch(true);
                if (preventDefault) {
                    e.preventDefault();
                    e.stopPropagation();
                }
                if (isHovering) {
                    if (element.onclick) element.onclick(e);
                    if (element.onmouseout) element.onmouseout(e);
                    isHovering = false;
                }
            }
        };
        module.exports.removeAllChildren = function(element) {
            while (element.hasChildNodes()) {
                element.removeChild(element.lastChild);
            }
        };
        module.exports.generateElement = function(config) {
            var element = document.createElement(config.tag || "div");

            function bind(configValue, elementValue) {
                if (config[configValue]) element[elementValue] = config[configValue];
            }
            bind("text", "textContent");
            bind("html", "innerHTML");
            bind("class", "className");
            for (var key in config) {
                switch (key) {
                    case "tag":
                    case "text":
                    case "html":
                    case "class":
                    case "style":
                    case "hookTouch":
                    case "parent":
                    case "children":
                        continue;
                    default:
                        break;
                }
                element[key] = config[key];
            }
            if (element.onclick) element.onclick = module.exports.checkTrusted(element.onclick);
            if (element.onmouseover) element.onmouseover = module.exports.checkTrusted(element.onmouseover);
            if (element.onmouseout) element.onmouseout = module.exports.checkTrusted(element.onmouseout);
            if (config.style) {
                element.style.cssText = config.style;
            }
            if (config.hookTouch) {
                module.exports.hookTouchEvents(element);
            }
            if (config.parent) {
                config.parent.appendChild(element);
            }
            if (config.children) {
                for (var i = 0; i < config.children.length; i++) {
                    element.appendChild(config.children[i]);
                }
            }
            return element;
        }
        module.exports.eventIsTrusted = function(ev) {
            if (ev && typeof ev.isTrusted == "boolean") {
                return ev.isTrusted;
            } else {
                return true;
            }
        }
        module.exports.checkTrusted = function(callback) {
            return function(ev) {
                if (ev && ev instanceof Event && module.exports.eventIsTrusted(ev)) {
                    callback(ev);
                } else {
                    //console.error("Event is not trusted.", ev);
                }
            }
        }
        module.exports.randomString = function(length) {
            var text = "";
            var possible = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
            for (var i = 0; i < length; i++) {
                text += possible.charAt(Math.floor(Math.random() * possible.length));
            }
            return text;
        };
        module.exports.countInArray = function(array, val) {
            var count = 0;
            for (var i = 0; i < array.length; i++) {
                if (array[i] === val) count++;
            }
            return count;
        };

    }),
    "./script/src/js/data/ai.js": (function(module) {
        module.exports = class {
            constructor(sid, objectManager, players, items, UTILS, config, scoreCallback, server) {
                this.sid = sid;
                this.isAI = true;
                this.nameIndex = UTILS.randInt(0, config.cowNames.length - 1);

                // INIT:
                this.init = function(x, y, dir, index, data) {
                    this.x = x;
                    this.y = y;
                    this.startX = data.fixedSpawn ? x : null;
                    this.startY = data.fixedSpawn ? y : null;
                    this.xVel = 0;
                    this.yVel = 0;
                    this.zIndex = 0;
                    this.dir = dir;
                    this.dirPlus = 0;
                    this.lastBleed = {
                        amount: 0,
                        time: 0,
                    };
                    this.index = index;
                    this.src = data.src;
                    if (data.name) this.name = data.name;
                    this.weightM = data.weightM;
                    this.speed = data.speed;
                    this.killScore = data.killScore;
                    this.turnSpeed = data.turnSpeed;
                    this.scale = data.scale;
                    this.maxHealth = data.health;
                    this.leapForce = data.leapForce;
                    this.health = this.maxHealth;
                    this.chargePlayer = data.chargePlayer;
                    this.viewRange = data.viewRange;
                    this.drop = data.drop;
                    this.dmg = data.dmg;
                    this.hostile = data.hostile;
                    this.dontRun = data.dontRun;
                    this.hitRange = data.hitRange;
                    this.hitDelay = data.hitDelay;
                    this.hitScare = data.hitScare;
                    this.spriteMlt = data.spriteMlt;
                    this.nameScale = data.nameScale;
                    this.colDmg = data.colDmg;
                    this.noTrap = data.noTrap;
                    this.spawnDelay = data.spawnDelay;
                    this.hitWait = 0;
                    this.waitCount = 1000;
                    this.moveCount = 0;
                    this.targetDir = 0;
                    this.active = true;
                    this.alive = true;
                    this.runFrom = null;
                    this.chargeTarget = null;
                    this.dmgOverTime = {};
                };

                // UPDATE:
                var timerCount = 0;
                this.update = function(delta) {
                    if (this.active) {

                        // SPAWN DELAY:
                        if (this.spawnCounter) {
                            this.spawnCounter -= delta;
                            if (this.spawnCounter <= 0) {
                                this.spawnCounter = 0;
                            }
                            return;
                        }

                        // REGENS AND AUTO:
                        timerCount -= delta;
                        if (timerCount <= 0) {
                            if (this.dmgOverTime.dmg) {
                                this.changeHealth(-this.dmgOverTime.dmg, this.dmgOverTime.doer);
                                this.dmgOverTime.time -= 1;
                                if (this.dmgOverTime.time <= 0) this.dmgOverTime.dmg = 0;
                            }
                            timerCount = 1000;
                        }

                        // BEHAVIOUR:
                        var charging = false;
                        var slowMlt = 1;
                        if (!this.zIndex && !this.lockMove && this.y2 >= (config.mapScale / 2) - (config.riverWidth / 2) &&
                            this.y <= (config.mapScale / 2) + (config.riverWidth / 2)) {
                            slowMlt = 0.33;
                            this.xVel += config.waterCurrent * delta;
                        }
                        if (this.lockMove) {
                            this.xVel = 0;
                            this.yVel = 0;
                        } else if (this.waitCount > 0) {
                            this.waitCount -= delta;
                            if (this.waitCount <= 0) {
                                if (this.chargePlayer) {
                                    var tmpPlayer, bestDst, tmpDist;
                                    for (var i = 0; i < players.length; ++i) {
                                        if (players[i].alive && !(players[i].skin && players[i].skin.bullRepel)) {
                                            tmpDist = UTILS.getDistance(this.x2, this.y2, players[i].x2, players[i].y2);
                                            if (tmpDist <= this.viewRange && (!tmpPlayer || tmpDist < bestDst)) {
                                                bestDst = tmpDist;
                                                tmpPlayer = players[i];
                                            }
                                        }
                                    }
                                    if (tmpPlayer) {
                                        this.chargeTarget = tmpPlayer;
                                        this.moveCount = UTILS.randInt(8000, 12000);
                                    } else {
                                        this.moveCount = UTILS.randInt(1000, 2000);
                                        this.targetDir = UTILS.randFloat(-Math.PI, Math.PI);
                                    }
                                } else {
                                    this.moveCount = UTILS.randInt(4000, 10000);
                                    this.targetDir = UTILS.randFloat(-Math.PI, Math.PI);
                                }
                            }
                        } else if (this.moveCount > 0) {
                            var tmpSpd = this.speed * slowMlt;
                            if (this.runFrom && this.runFrom.active && !(this.runFrom.isPlayer && !this.runFrom.alive)) {
                                this.targetDir = UTILS.getDirection(this.x2, this.y2, this.runFrom.x, this.runFrom.y);
                                tmpSpd *= 1.42;
                            } else if (this.chargeTarget && this.chargeTarget.alive) {
                                this.targetDir = UTILS.getDirection(this.chargeTarget.x, this.chargeTarget.y, this.x2, this.y2);
                                tmpSpd *= 1.75;
                                charging = true;
                            }
                            if (this.hitWait) {
                                tmpSpd *= 0.3;
                            }
                            this.moveCount -= delta;
                            if (this.moveCount <= 0) {
                                this.runFrom = null;
                                this.chargeTarget = null;
                                this.waitCount = this.hostile ? 1500 : UTILS.randInt(1500, 6000);
                            }
                        }

                        // OBJECT COLL:
                        this.zIndex = 0;
                        this.lockMove = false;
                        let tmpList = objectManager.getObjects(this.x2, this.y2, this.scale);
                        for (let tmpObj of tmpList) {
                            objectManager.checkCollision(this, tmpObj);
                        }

                        // HITTING:
                        let hitting = false;
                        if (this.hitWait > 0) {
                            this.hitWait -= delta;
                            if (this.hitWait <= 0) {
                                hitting = true;
                                this.hitWait = 0;
                                let tmpList = objectManager.getObjects(this.x2, this.y2, this.hitRange);
                                let tmpDst;
                                for (let tmpObj of tmpList) {
                                    if (tmpObj.health) {
                                        tmpDst = UTILS.getDistance(this.x2, this.y2, tmpObj.x2, tmpObj.y2);
                                        if (tmpDst < tmpObj.scale + this.hitRange) {
                                            if (tmpObj.changeHealth(-this.dmg * 5)) { }
                                        }
                                    }
                                }
                            }
                        }

                        // PLAYER COLLISIONS:
                        if (charging || hitting) {
                            var tmpObj, tmpDst, tmpDir;
                            for (let i = 0; i < players.length; ++i) {
                                tmpObj = players[i];
                                if (tmpObj && tmpObj.alive) {
                                    tmpDst = UTILS.getDistance(this.x2, this.y2, tmpObj.x2, tmpObj.y2);
                                    if (this.hitRange) {
                                        if (!this.hitWait && tmpDst <= this.hitRange + tmpObj.scale) {
                                            if (hitting) {
                                                tmpDir = UTILS.getDirection(tmpObj.x2, tmpObj.y2, this.x2, this.y2);
                                                this.runFrom = null;
                                                this.chargeTarget = null;
                                                this.waitCount = 3000;
                                                this.hitWait = (!UTILS.randInt(0, 2) ? 600 : 0);
                                            } else this.hitWait = this.hitDelay;
                                        }
                                    } else if (tmpDst <= this.scale + tmpObj.scale) {
                                        tmpDir = UTILS.getDirection(tmpObj.x2, tmpObj.y2, this.x2, this.y2);
                                    }
                                }
                            }
                        }
                    }
                }

                // CAN SEE:
                this.canSee = function(other) {
                    if (!other) return false;
                    if (other.skin && other.skin.invisTimer && other.noMovTimer >= other.skin.invisTimer) return false;
                    var dx = Math.abs(other[other.isPlayer || other.isAI ? "x2" : "x"] - this.x2) - other.scale;
                    var dy = Math.abs(other[other.isPlayer || other.isAI ? "y2" : "y"] - this.y2) - other.scale;
                    return dx <= (config.maxScreenWidth / 2) * 1.3 && dy <= (config.maxScreenHeight / 2) * 1.3;
                };

                var tmpRatio = 0;
                var animIndex = 0;
                this.animate = function(delta) {
                    if (this.animTime > 0) {
                        this.animTime -= delta;
                        if (this.animTime <= 0) {
                            this.animTime = 0;
                            this.dirPlus = 0;
                            tmpRatio = 0;
                            animIndex = 0;
                        } else {
                            if (animIndex == 0) {
                                tmpRatio += delta / (this.animSpeed * config.hitReturnRatio);
                                this.dirPlus = UTILS.lerp(0, this.targetAngle, Math.min(1, tmpRatio));
                                if (tmpRatio >= 1) {
                                    tmpRatio = 1;
                                    animIndex = 1;
                                }
                            } else {
                                tmpRatio -= delta / (this.animSpeed * (1 - config.hitReturnRatio));
                                this.dirPlus = UTILS.lerp(0, this.targetAngle, Math.max(0, tmpRatio));
                            }
                        }
                    }
                };

                // ANIMATION:
                this.startAnim = function() {
                    this.animTime = this.animSpeed = 600;
                    this.targetAngle = Math.PI * 0.8;
                    tmpRatio = 0;
                    animIndex = 0;
                };

                // CHANGE HEALTH:
                this.changeHealth = function(val, doer, runFrom) {
                    if (this.active) {
                        this.health += val;
                        if (runFrom) {
                            if (this.hitScare && !UTILS.randInt(0, this.hitScare)) {
                                this.runFrom = runFrom;
                                this.waitCount = 0;
                                this.moveCount = 2000;
                            } else if (this.hostile && this.chargePlayer && runFrom.isPlayer) {
                                this.chargeTarget = runFrom;
                                this.waitCount = 0;
                                this.moveCount = 8000;
                            } else if (!this.dontRun) {
                                this.runFrom = runFrom;
                                this.waitCount = 0;
                                this.moveCount = 2000;
                            }
                        }
                        if (val < 0 && this.hitRange && UTILS.randInt(0, 1)) this.hitWait = 500;
                        if (this.health <= 0) {
                            if (this.spawnDelay) {
                                this.spawnCounter = this.spawnDelay;
                            }
                            this.health = this.maxHealth;
                            this.runFrom = null;
                        }
                    }
                };
            };
        };
    }),

    "./script/src/js/data/aiManager.js": (function(module) {

        // AI MANAGER:
        module.exports = class {
            constructor(ais, AI, players, items, objectManager, config, UTILS, scoreCallback, server) {

                // AI TYPES:
                this.aiTypes = [{
                    id: 0,
                    src: "cow_1",
                    killScore: 150,
                    health: 500,
                    weightM: 0.8,
                    speed: 0.00095,
                    turnSpeed: 0.001,
                    scale: 72,
                    drop: ["food", 50]
                }, {
                    id: 1,
                    src: "pig_1",
                    killScore: 200,
                    health: 800,
                    weightM: 0.6,
                    speed: 0.00085,
                    turnSpeed: 0.001,
                    scale: 72,
                    drop: ["food", 80]
                }, {
                    id: 2,
                    name: "Bull",
                    src: "bull_2",
                    hostile: true,
                    dmg: 20,
                    killScore: 1000,
                    health: 1800,
                    weightM: 0.5,
                    speed: 0.00094,
                    turnSpeed: 0.00074,
                    scale: 78,
                    viewRange: 800,
                    chargePlayer: true,
                    drop: ["food", 100]
                }, {
                    id: 3,
                    name: "Bully",
                    src: "bull_1",
                    hostile: true,
                    dmg: 20,
                    killScore: 2000,
                    health: 2800,
                    weightM: 0.45,
                    speed: 0.001,
                    turnSpeed: 0.0008,
                    scale: 90,
                    viewRange: 900,
                    chargePlayer: true,
                    drop: ["food", 400]
                }, {
                    id: 4,
                    name: "Wolf",
                    src: "wolf_1",
                    hostile: true,
                    dmg: 8,
                    killScore: 500,
                    health: 300,
                    weightM: 0.45,
                    speed: 0.001,
                    turnSpeed: 0.002,
                    scale: 84,
                    viewRange: 800,
                    chargePlayer: true,
                    drop: ["food", 200]
                }, {
                    id: 5,
                    name: "Quack",
                    src: "chicken_1",
                    dmg: 8,
                    killScore: 2000,
                    noTrap: true,
                    health: 300,
                    weightM: 0.2,
                    speed: 0.0018,
                    turnSpeed: 0.006,
                    scale: 70,
                    drop: ["food", 100]
                }, {
                    id: 6,
                    name: "MOOSTAFA",
                    nameScale: 50,
                    src: "enemy",
                    hostile: true,
                    dontRun: true,
                    fixedSpawn: true,
                    spawnDelay: 60000,
                    noTrap: true,
                    colDmg: 100,
                    dmg: 40,
                    killScore: 8000,
                    health: 18000,
                    weightM: 0.4,
                    speed: 0.0007,
                    turnSpeed: 0.01,
                    scale: 80,
                    spriteMlt: 1.8,
                    leapForce: 0.9,
                    viewRange: 1000,
                    hitRange: 210,
                    hitDelay: 1000,
                    chargePlayer: true,
                    drop: ["food", 100]
                }, {
                    id: 7,
                    name: "Treasure",
                    hostile: true,
                    nameScale: 35,
                    src: "crate_1",
                    fixedSpawn: true,
                    spawnDelay: 120000,
                    colDmg: 200,
                    killScore: 5000,
                    health: 20000,
                    weightM: 0.1,
                    speed: 0.0,
                    turnSpeed: 0.0,
                    scale: 70,
                    spriteMlt: 1.0
                }, {
                    id: 8,
                    name: "MOOFIE",
                    src: "wolf_2",
                    hostile: true,
                    fixedSpawn: true,
                    dontRun: true,
                    hitScare: 4,
                    spawnDelay: 30000,
                    noTrap: true,
                    nameScale: 35,
                    dmg: 10,
                    colDmg: 100,
                    killScore: 3000,
                    health: 7000,
                    weightM: 0.45,
                    speed: 0.0015,
                    turnSpeed: 0.002,
                    scale: 90,
                    viewRange: 800,
                    chargePlayer: true,
                    drop: ["food", 1000]
                }];

                // SPAWN AI:
                this.spawn = function(x, y, dir, index) {
                    var tmpObj;
                    for (var i = 0; i < ais.length; ++i) {
                        if (!ais[i].active) {
                            tmpObj = ais[i];
                            break;
                        }
                    }
                    if (!tmpObj) {
                        tmpObj = new AI(ais.length, objectManager, players, items, UTILS, config, scoreCallback, server);
                        ais.push(tmpObj);
                    }
                    tmpObj.init(x, y, dir, index, this.aiTypes[index]);
                    return tmpObj;
                };

            };
        };
    }),

    "./script/src/js/data/gameObject.js": (function(module) {

        module.exports = class {
            constructor(sid) {
                this.sid = sid;

                // INIT:
                this.init = function(x, y, dir, scale, type, data, owner) {
                    data = data || {};
                    this.isObject = true;
                    this.sentTo = {};
                    this.gridLocations = [];
                    this.active = true;
                    this.doUpdate = data.doUpdate;
                    this.x = x;
                    this.y = y;
                    this.dir = dir;
                    this.lastWiggle = 0;
                    this.xWiggle = 0;
                    this.yWiggle = 0;
                    this.scale = scale;
                    this.type = type;
                    this.id = data.id;
                    this.owner = owner;
                    this.name = data.name;
                    this.isItem = (this.id != undefined);
                    this.group = data.group;
                    this.health = data.health;
                    this.layer = 2;
                    if (this.group != undefined) {
                        this.layer = this.group.layer;
                    } else if (this.type == 0) {
                        this.layer = 3;
                    } else if (this.type == 2) {
                        this.layer = 0;
                    } else if (this.type == 4) {
                        this.layer = -1;
                    }
                    this.colDiv = data.colDiv || 1;
                    this.blocker = data.blocker;
                    this.ignoreCollision = data.ignoreCollision;
                    this.dontGather = data.dontGather;
                    this.hideFromEnemy = data.hideFromEnemy;
                    this.friction = data.friction;
                    this.projDmg = data.projDmg;
                    this.dmg = data.dmg;
                    this.pDmg = data.pDmg;
                    this.pps = data.pps;
                    this.zIndex = data.zIndex || 0;
                    this.turnSpeed = data.turnSpeed;
                    this.req = data.req;
                    this.trap = data.trap;
                    this.healCol = data.healCol;
                    this.teleport = data.teleport;
                    this.boostSpeed = data.boostSpeed;
                    this.projectile = data.projectile;
                    this.shootRange = data.shootRange;
                    this.shootRate = data.shootRate;
                    this.shootCount = this.shootRate;
                    this.spawnPoint = data.spawnPoint;
                };

                // GET HIT:
                this.changeHealth = function(amount, doer) {
                    this.health += amount;
                    return (this.health <= 0);
                };

                // GET SCALE:
                this.getScale = function(sM, ig) {
                    sM = sM || 1;
                    return this.scale * ((this.isItem || this.type == 2 || this.type == 3 || this.type == 4) ?
                                         1 : (0.6 * sM)) * (ig ? 1 : this.colDiv);
                };

                // VISIBLE TO PLAYER:
                this.visibleToPlayer = function(player) {
                    return this.trap ? !this.hideFromEnemy || (this.owner.sid == player.sid) : true;
                };

                // UPDATE:
                this.update = function(delta) {
                    if (this.active) {
                        if (this.xWiggle) {
                            this.xWiggle *= Math.pow(0.99, delta);
                        }
                        if (this.yWiggle) {
                            this.yWiggle *= Math.pow(0.99, delta);
                        }
                        if (this.turnSpeed) {
                            this.dir += this.turnSpeed * delta;
                        }
                    }
                };
            };
        }

    }),

    "./script/src/js/data/items.js": (function(module) {


        // ITEM GROUPS:
        module.exports.groups = [{
            id: 0,
            name: "food",
            layer: 0
        }, {
            id: 1,
            name: "walls",
            place: true,
            limit: 30,
            layer: 0
        }, {
            id: 2,
            name: "spikes",
            place: true,
            limit: 15,
            layer: 0
        }, {
            id: 3,
            name: "mill",
            place: true,
            limit: 7,
            layer: 1
        }, {
            id: 4,
            name: "mine",
            place: true,
            limit: 1,
            layer: 0
        }, {
            id: 5,
            name: "trap",
            place: true,
            limit: 6,
            layer: -1
        }, {
            id: 6,
            name: "booster",
            place: true,
            limit: 12,
            layer: -1
        }, {
            id: 7,
            name: "turret",
            place: true,
            limit: 2,
            layer: 1
        }, {
            id: 8,
            name: "watchtower",
            place: true,
            limit: 12,
            layer: 1
        }, {
            id: 9,
            name: "buff",
            place: true,
            limit: 4,
            layer: -1
        }, {
            id: 10,
            name: "spawn",
            place: true,
            limit: 1,
            layer: -1
        }, {
            id: 11,
            name: "sapling",
            place: true,
            limit: 2,
            layer: 0
        }, {
            id: 12,
            name: "blocker",
            place: true,
            limit: 3,
            layer: -1
        }, {
            id: 13,
            name: "teleporter",
            place: true,
            limit: 2,
            layer: -1
        }];

        // PROJECTILES:
        module.exports.projectiles = [{
            indx: 0,
            layer: 0,
            src: "arrow_1",
            dmg: 25,
            speed: 1.6,
            scale: 103,
            range: 1000
        }, {
            indx: 1,
            layer: 1,
            dmg: 25,
            scale: 20,
            range: 700,
        }, {
            indx: 0,
            layer: 0,
            src: "arrow_1",
            dmg: 35,
            speed: 2.5,
            scale: 103,
            range: 1200
        }, {
            indx: 0,
            layer: 0,
            src: "arrow_1",
            dmg: 30,
            speed: 2,
            scale: 103,
            range: 1200
        }, {
            indx: 1,
            layer: 1,
            dmg: 16,
            scale: 20
        }, {
            indx: 0,
            layer: 0,
            src: "bullet_1",
            dmg: 50,
            speed: 3.6,
            scale: 160,
            range: 1400
        }];

        // WEAPONS:
        module.exports.weapons = [{
            id: 0,
            type: 0,
            name: "tool hammer",
            desc: "tool for gathering all resources",
            src: "hammer_1",
            length: 140,
            width: 140,
            xOff: -3,
            yOff: 18,
            dmg: 25,
            range: 65,
            gather: 1,
            speed: 300
        }, {
            id: 1,
            type: 0,
            age: 2,
            name: "hand axe",
            desc: "gathers resources at a higher rate",
            src: "axe_1",
            length: 140,
            width: 140,
            xOff: 3,
            yOff: 24,
            dmg: 30,
            spdMult: 1,
            range: 70,
            gather: 2,
            speed: 400
        }, {
            id: 2,
            type: 0,
            age: 8,
            pre: 1,
            name: "great axe",
            desc: "deal more damage and gather more resources",
            src: "great_axe_1",
            length: 140,
            width: 140,
            xOff: -8,
            yOff: 25,
            dmg: 35,
            spdMult: 1,
            range: 75,
            gather: 4,
            speed: 400
        }, {
            id: 3,
            type: 0,
            age: 2,
            name: "short sword",
            desc: "increased attack power but slower move speed",
            src: "sword_1",
            iPad: 1.3,
            length: 130,
            width: 210,
            xOff: -8,
            yOff: 46,
            dmg: 35,
            spdMult: 0.85,
            range: 110,
            gather: 1,
            speed: 300
        }, {
            id: 4,
            type: 0,
            age: 8,
            pre: 3,
            name: "katana",
            desc: "greater range and damage",
            src: "samurai_1",
            iPad: 1.3,
            length: 130,
            width: 210,
            xOff: -8,
            yOff: 59,
            dmg: 40,
            spdMult: 0.8,
            range: 118,
            gather: 1,
            speed: 300
        }, {
            id: 5,
            type: 0,
            age: 2,
            name: "polearm",
            desc: "long range melee weapon",
            src: "spear_1",
            iPad: 1.3,
            length: 130,
            width: 210,
            xOff: -8,
            yOff: 53,
            dmg: 45,
            knock: 0.2,
            spdMult: 0.82,
            range: 142,
            gather: 1,
            speed: 700
        }, {
            id: 6,
            type: 0,
            age: 2,
            name: "bat",
            desc: "fast long range melee weapon",
            src: "bat_1",
            iPad: 1.3,
            length: 110,
            width: 180,
            xOff: -8,
            yOff: 53,
            dmg: 20,
            knock: 0.7,
            range: 110,
            gather: 1,
            speed: 300
        }, {
            id: 7,
            type: 0,
            age: 2,
            name: "daggers",
            desc: "really fast short range weapon",
            src: "dagger_1",
            iPad: 0.8,
            length: 110,
            width: 110,
            xOff: 18,
            yOff: 0,
            dmg: 20,
            knock: 0.1,
            range: 65,
            gather: 1,
            hitSlow: 0.1,
            spdMult: 1.13,
            speed: 100
        }, {
            id: 8,
            type: 0,
            age: 2,
            name: "stick",
            desc: "great for gathering but very weak",
            src: "stick_1",
            length: 140,
            width: 140,
            xOff: 3,
            yOff: 24,
            dmg: 1,
            spdMult: 1,
            range: 70,
            gather: 7,
            speed: 400
        }, {
            id: 9,
            type: 1,
            age: 6,
            name: "hunting bow",
            desc: "bow used for ranged combat and hunting",
            src: "bow_1",
            req: ["wood", 4],
            length: 120,
            width: 120,
            xOff: -6,
            yOff: 0,
            projectile: 0,
            spdMult: 0.75,
            speed: 600
        }, {
            id: 10,
            type: 1,
            age: 6,
            name: "great hammer",
            desc: "hammer used for destroying structures",
            src: "great_hammer_1",
            length: 140,
            width: 140,
            xOff: -9,
            yOff: 25,
            dmg: 10,
            spdMult: 0.88,
            range: 75,
            sDmg: 7.5,
            gather: 1,
            speed: 400
        }, {
            id: 11,
            type: 1,
            age: 6,
            name: "wooden shield",
            desc: "blocks projectiles and reduces melee damage",
            src: "shield_1",
            length: 120,
            width: 120,
            shield: 0.2,
            xOff: 6,
            yOff: 0,
            spdMult: 0.7
        }, {
            id: 12,
            type: 1,
            age: 8,
            pre: 9,
            name: "crossbow",
            desc: "deals more damage and has greater range",
            src: "crossbow_1",
            req: ["wood", 5],
            aboveHand: true,
            armS: 0.75,
            length: 120,
            width: 120,
            xOff: -4,
            yOff: 0,
            projectile: 2,
            spdMult: 0.7,
            speed: 700
        }, {
            id: 13,
            type: 1,
            age: 9,
            pre: 12,
            name: "repeater crossbow",
            desc: "high firerate crossbow with reduced damage",
            src: "crossbow_2",
            req: ["wood", 10],
            aboveHand: true,
            armS: 0.75,
            length: 120,
            width: 120,
            xOff: -4,
            yOff: 0,
            projectile: 3,
            spdMult: 0.7,
            speed: 230
        }, {
            id: 14,
            type: 1,
            age: 6,
            name: "mc grabby",
            desc: "steals resources from enemies",
            src: "grab_1",
            length: 130,
            width: 210,
            xOff: -8,
            yOff: 53,
            dmg: 0,
            steal: 250,
            knock: 0.2,
            spdMult: 1.05,
            range: 125,
            gather: 0,
            speed: 700
        }, {
            id: 15,
            type: 1,
            age: 9,
            pre: 12,
            name: "musket",
            desc: "slow firerate but high damage and range",
            src: "musket_1",
            req: ["stone", 10],
            aboveHand: true,
            rec: 0.35,
            armS: 0.6,
            hndS: 0.3,
            hndD: 1.6,
            length: 205,
            width: 205,
            xOff: 25,
            yOff: 0,
            projectile: 5,
            hideProjectile: true,
            spdMult: 0.6,
            speed: 1500
        }];

        // ITEMS:
        module.exports.list = [{
            group: module.exports.groups[0],
            name: "apple",
            desc: "restores 20 health when consumed",
            req: ["food", 10],
            consume: 20,
            scale: 22,
            holdOffset: 15
        }, {
            age: 3,
            group: module.exports.groups[0],
            name: "cookie",
            desc: "restores 40 health when consumed",
            req: ["food", 15],
            consume: 40,
            scale: 27,
            holdOffset: 15
        }, {
            age: 7,
            group: module.exports.groups[0],
            name: "cheese",
            desc: "restores 30 health and another 50 over 5 seconds",
            req: ["food", 25],
            consume: 30,
            scale: 27,
            holdOffset: 15
        }, {
            group: module.exports.groups[1],
            name: "wood wall",
            desc: "provides protection for your village",
            req: ["wood", 10],
            projDmg: true,
            health: 380,
            scale: 50,
            holdOffset: 20,
            placeOffset: -5
        }, {
            age: 3,
            group: module.exports.groups[1],
            name: "stone wall",
            desc: "provides improved protection for your village",
            req: ["stone", 25],
            health: 900,
            scale: 50,
            holdOffset: 20,
            placeOffset: -5
        }, {
            age: 7,
            pre: 1,
            group: module.exports.groups[1],
            name: "castle wall",
            desc: "provides powerful protection for your village",
            req: ["stone", 35],
            health: 1500,
            scale: 52,
            holdOffset: 20,
            placeOffset: -5
        }, {
            group: module.exports.groups[2],
            name: "spikes",
            desc: "damages enemies when they touch them",
            req: ["wood", 20, "stone", 5],
            health: 400,
            dmg: 20,
            scale: 49,
            spritePadding: -23,
            holdOffset: 8,
            placeOffset: -5
        }, {
            age: 5,
            group: module.exports.groups[2],
            name: "greater spikes",
            desc: "damages enemies when they touch them",
            req: ["wood", 30, "stone", 10],
            health: 500,
            dmg: 35,
            scale: 52,
            spritePadding: -23,
            holdOffset: 8,
            placeOffset: -5
        }, {
            age: 9,
            pre: 1,
            group: module.exports.groups[2],
            name: "poison spikes",
            desc: "poisons enemies when they touch them",
            req: ["wood", 35, "stone", 15],
            health: 600,
            dmg: 30,
            pDmg: 5,
            scale: 52,
            spritePadding: -23,
            holdOffset: 8,
            placeOffset: -5
        }, {
            age: 9,
            pre: 2,
            group: module.exports.groups[2],
            name: "spinning spikes",
            desc: "damages enemies when they touch them",
            req: ["wood", 30, "stone", 20],
            health: 500,
            dmg: 45,
            turnSpeed: 0.003,
            scale: 52,
            spritePadding: -23,
            holdOffset: 8,
            placeOffset: -5
        }, {
            group: module.exports.groups[3],
            name: "windmill",
            desc: "generates gold over time",
            req: ["wood", 50, "stone", 10],
            health: 400,
            pps: 1,
            turnSpeed: 0.0016,
            spritePadding: 25,
            iconLineMult: 12,
            scale: 45,
            holdOffset: 20,
            placeOffset: 5
        }, {
            age: 5,
            pre: 1,
            group: module.exports.groups[3],
            name: "faster windmill",
            desc: "generates more gold over time",
            req: ["wood", 60, "stone", 20],
            health: 500,
            pps: 1.5,
            turnSpeed: 0.0025,
            spritePadding: 25,
            iconLineMult: 12,
            scale: 47,
            holdOffset: 20,
            placeOffset: 5
        }, {
            age: 8,
            pre: 1,
            group: module.exports.groups[3],
            name: "power mill",
            desc: "generates more gold over time",
            req: ["wood", 100, "stone", 50],
            health: 800,
            pps: 2,
            turnSpeed: 0.005,
            spritePadding: 25,
            iconLineMult: 12,
            scale: 47,
            holdOffset: 20,
            placeOffset: 5
        }, {
            age: 5,
            group: module.exports.groups[4],
            type: 2,
            name: "mine",
            desc: "allows you to mine stone",
            req: ["wood", 20, "stone", 100],
            iconLineMult: 12,
            scale: 65,
            holdOffset: 20,
            placeOffset: 0
        }, {
            age: 5,
            group: module.exports.groups[11],
            type: 0,
            name: "sapling",
            desc: "allows you to farm wood",
            req: ["wood", 150],
            iconLineMult: 12,
            colDiv: 0.5,
            scale: 110,
            holdOffset: 50,
            placeOffset: -15
        }, {
            age: 4,
            group: module.exports.groups[5],
            name: "pit trap",
            desc: "pit that traps enemies if they walk over it",
            req: ["wood", 30, "stone", 30],
            trap: true,
            ignoreCollision: true,
            hideFromEnemy: true,
            health: 500,
            colDiv: 0.2,
            scale: 50,
            holdOffset: 20,
            placeOffset: -5
        }, {
            age: 4,
            group: module.exports.groups[6],
            name: "boost pad",
            desc: "provides boost when stepped on",
            req: ["stone", 20, "wood", 5],
            ignoreCollision: true,
            boostSpeed: 1.5,
            health: 150,
            colDiv: 0.7,
            scale: 45,
            holdOffset: 20,
            placeOffset: -5
        }, {
            age: 7,
            group: module.exports.groups[7],
            doUpdate: true,
            name: "turret",
            desc: "defensive structure that shoots at enemies",
            req: ["wood", 200, "stone", 150],
            health: 800,
            projectile: 1,
            shootRange: 700,
            shootRate: 2200,
            scale: 43,
            holdOffset: 20,
            placeOffset: -5
        }, {
            age: 7,
            group: module.exports.groups[8],
            name: "platform",
            desc: "platform to shoot over walls and cross over water",
            req: ["wood", 20],
            ignoreCollision: true,
            zIndex: 1,
            health: 300,
            scale: 43,
            holdOffset: 20,
            placeOffset: -5
        }, {
            age: 7,
            group: module.exports.groups[9],
            name: "healing pad",
            desc: "standing on it will slowly heal you",
            req: ["wood", 30, "food", 10],
            ignoreCollision: true,
            healCol: 15,
            health: 400,
            colDiv: 0.7,
            scale: 45,
            holdOffset: 20,
            placeOffset: -5
        }, {
            age: 9,
            group: module.exports.groups[10],
            name: "spawn pad",
            desc: "you will spawn here when you die but it will dissapear",
            req: ["wood", 100, "stone", 100],
            health: 400,
            ignoreCollision: true,
            spawnPoint: true,
            scale: 45,
            holdOffset: 20,
            placeOffset: -5
        }, {
            age: 7,
            group: module.exports.groups[12],
            name: "blocker",
            desc: "blocks building in radius",
            req: ["wood", 30, "stone", 25],
            ignoreCollision: true,
            blocker: 300,
            health: 400,
            colDiv: 0.7,
            scale: 45,
            holdOffset: 20,
            placeOffset: -5
        }, {
            age: 7,
            group: module.exports.groups[13],
            name: "teleporter",
            desc: "teleports you to a random point on the map",
            req: ["wood", 60, "stone", 60],
            ignoreCollision: true,
            teleport: true,
            health: 200,
            colDiv: 0.7,
            scale: 45,
            holdOffset: 20,
            placeOffset: -5
        }];

        // ASSIGN IDS:
        for (var i = 0; i < module.exports.list.length; ++i) {
            module.exports.list[i].id = i;
            if (module.exports.list[i].pre) module.exports.list[i].pre = i - module.exports.list[i].pre;
        }


    }),
    "./script/src/js/data/objectManager.js": (function(module) {

        var mathFloor = Math.floor;
        var mathABS = Math.abs;
        var mathCOS = Math.cos;
        var mathSIN = Math.sin;
        var mathPOW = Math.pow;
        var mathSQRT = Math.sqrt;
        module.exports = class {
            constructor(GameObject, gameObjects, UTILS, config, items, Projectile, players, server) {
                this.objects = gameObjects;
                this.updateObjects = [];


                // ADD NEW:
                var tmpObj;
                this.add = function(sid, x, y, dir, s, type, data, setSID, owner) {
                    tmpObj = null;
                    for (var i = 0; i < gameObjects.length; ++i) {
                        if (gameObjects[i].sid == sid) {
                            tmpObj = gameObjects[i];
                            break;
                        }
                    }
                    if (!tmpObj) {
                        for (let i = 0; i < gameObjects.length; ++i) {
                            if (!gameObjects[i].active) {
                                tmpObj = gameObjects[i];
                                break;
                            }
                        }
                    }
                    if (!tmpObj) {
                        tmpObj = new GameObject(sid);
                        gameObjects.push(tmpObj);
                    }
                    if (setSID) tmpObj.sid = sid;
                    tmpObj.init(x, y, dir, s, type, data, owner);
                    if (tmpObj.doUpdate) this.updateObjects.push(tmpObj);
                };

                // DISABLE BY SID:
                this.disableBySid = function(sid) {
                    for (var i = 0; i < gameObjects.length; ++i) {
                        if (gameObjects[i].sid == sid) {
                            this.disableObj(gameObjects[i]);
                            break;
                        }
                    }
                };

                // DISABLE OBJ:
                this.disableObj = function(obj) {
                    obj.active = false;
                    if (obj.owner && obj.pps) obj.owner.pps -= obj.pps;
                    var tmpIndx = this.updateObjects.indexOf(obj);
                    if (tmpIndx >= 0) {
                        this.updateObjects.splice(tmpIndx, 1);
                    }
                };

                // REMOVE ALL FROM PLAYER:
                this.removeAllItems = function(sid, server) {
                    for (var i = 0; i < gameObjects.length; ++i) {
                        if (gameObjects[i].active && gameObjects[i].owner && gameObjects[i].owner.sid == sid) {
                            this.disableObj(gameObjects[i]);
                        }
                    }
                };

                // GET OBJECT ARRAY:
                this.getObjects = function(xPos, yPos, s) {
                    return gameObjects.filter(e => e.active && UTILS.getDistance(xPos, yPos, e.x, e.y) <= e.scale + s);
                };

                // CHECK IF PLACABLE:
                this.checkItemLocation = function(x, y, s, sM, indx, ignoreWater, placer) {
                    for (let tmpObj of gameObjects) {
                        var blockS = (tmpObj.blocker || tmpObj.getScale(sM, tmpObj.isItem));
                        if (UTILS.getDistance(x, y, tmpObj.x, tmpObj.y) < (s + blockS)) return tmpObj;
                    }
                    if (!ignoreWater && indx != 18 && y >= (config.mapScale / 2) - (config.riverWidth / 2) && y <= (config
                                                                                                                    .mapScale / 2) + (config.riverWidth / 2)) {
                        return false;
                    }
                    return true;
                };

                // CHECK PLAYER COLLISION:
                this.checkCollision = function(player, other, delta) {
                    delta = delta || 1;
                    let tmpLen = player.scale + (other.getScale ? other.getScale() : other.scale);
                    if (UTILS.getDistance(player.x2, player.y2, other.x, other.y) <= tmpLen) {
                        if (!other.ignoreCollision) {
                            var tmpDir = UTILS.getDirection(player.x2, player.y2, other.x, other.y);
                            var tmpDist = UTILS.getDistance(player.x2, player.y2, other.x, other.y);
                            if (other.dmg && other.owner.sid != player.sid) {
                                if (other.pDmg && !(player.skin && player.skin.poisonRes)) {
                                    player.dmgOverTime.dmg = other.pDmg;
                                    player.dmgOverTime.time = 5;
                                    player.dmgOverTime.doer = other.owner;
                                }
                            }
                        } else if (other.trap && !player.noTrap && other.owner.sid != player.sid) {
                            player.lockMove = true;
                            other.hideFromEnemy = false;
                        } else if (other.boostSpeed) { } else if (other.healCol) {
                            player.healCol = other.healCol;
                        } else if (other.teleport) { }
                        if (other.zIndex > player.zIndex) player.zIndex = other.zIndex;
                        return true;
                    }
                    return false;
                };

            };
        };
    }),

    "./script/src/js/data/player.js": (function(module) {
        var mathABS = Math.abs;
        var mathCOS = Math.cos;
        var mathSIN = Math.sin;
        var mathPOW = Math.pow;
        var mathSQRT = Math.sqrt;
        module.exports = class {
            constructor(id, sid, config, UTILS, projectileManager,
                         objectManager, players, ais, items, hats, accessories, server, scoreCallback, iconCallback) {
                this.id = id;
                this.sid = sid;
                this.tmpScore = 0;
                this.team = null;
                this.skinIndex = 0;
                this.tailIndex = 0;
                this.lastBleed = {
                    amount: 0,
                    time: 0,
                    healed: true,
                };
                this.lastHeal = {
                    amount: 0,
                    time: 0,
                };
                this.tails = {};
                for (var i = 0; i < accessories.length; ++i) {
                    if (accessories[i].price <= 0) this.tails[accessories[i].id] = 1;
                }
                this.skins = {};
                for (let i = 0; i < hats.length; ++i) {
                    if (hats[i].price <= 0) this.skins[hats[i].id] = 1;
                }
                this.points = 0;
                this.dt = 0;
                this.hidden = false;
                this.itemCounts = {};
                this.isPlayer = true;
                this.pps = 0;
                this.moveDir = undefined;
                this.skinRot = 0;
                this.lastPing = 0;
                this.iconIndex = 0;
                this.skinColor = 0;
                this.lastHit = 0;

                // SPAWN:
                this.spawn = function(moofoll) {
                    this.active = true;
                    this.alive = true;
                    this.lockMove = false;
                    this.lockDir = false;
                    this.minimapCounter = 0;
                    this.chatCountdown = 0;
                    this.shameCount = 0;
                    this.shameTimer = 0;
                    this.sentTo = {};
                    this.gathering = 0;
                    this.autoGather = 0;
                    this.animTime = 0;
                    this.animSpeed = 0;
                    this.mouseState = 0;
                    this.buildIndex = -1;
                    this.weaponIndex = 0;
                    this.dmgOverTime = {};
                    this.noMovTimer = 0;
                    this.maxXP = 300;
                    this.XP = 0;
                    this.age = 1;
                    this.kills = 0;
                    this.upgrAge = 2;
                    this.upgradePoints = 0;
                    this.x = 0;
                    this.y = 0;
                    this.zIndex = 0;
                    this.slowMult = 1;
                    this.dir = 0;
                    this.dirPlus = 0;
                    this.targetDir = 0;
                    this.targetAngle = 0;
                    this.maxHealth = 100;
                    this.health = this.maxHealth;
                    this.scale = config.playerScale;
                    this.speed = config.playerSpeed;
                    this.resetMoveDir();
                    this.resetResources(moofoll);
                    this.items = [0, 3, 6, 10];
                    this.weapons = [0];
                    this.variants = [];
                    this.shootCount = 0;
                    this.weaponXP = [];
                    this.reloads = [];
                    for (let i = 0; i <= 15; i++) {
                        this.reloads.push(0);
                        this.weaponXP.push(0);
                        this.variants.push(0);
                    }
                };

                // RESET MOVE DIR:
                this.resetMoveDir = function() {
                    this.moveDir = undefined;
                };

                // RESET RESOURCES:
                this.resetResources = function(moofoll) {
                    for (var i = 0; i < config.resourceTypes.length; ++i) {
                        this[config.resourceTypes[i]] = moofoll ? 100 : 0;
                    }
                };

                // ADD ITEM:
                this.addItem = function(id) {
                    var tmpItem = items.list[id];
                    if (tmpItem) {
                        for (var i = 0; i < this.items.length; ++i) {
                            if (items.list[this.items[i]].group == tmpItem.group) {
                                if (this.buildIndex == this.items[i]) this.buildIndex = id;
                                this.items[i] = id;
                                return true;
                            }
                        }
                        this.items.push(id);
                        return true;
                    }
                    return false;
                };

                // GET DATA TO SEND:
                this.getData = function() {
                    return [
                        this.id,
                        this.sid,
                        this.name,
                        UTILS.fixTo(this.x, 2),
                        UTILS.fixTo(this.y, 2),
                        UTILS.fixTo(this.dir, 3),
                        this.health,
                        this.maxHealth,
                        this.scale,
                        this.skinColor
                    ];
                };

                // SET DATA:
                this.setData = function(data) {
                    this.id = data[0];
                    this.sid = data[1];
                    this.name = data[2];
                    this.x = data[3];
                    this.y = data[4];
                    this.dir = data[5];
                    this.health = data[6];
                    this.maxHealth = data[7];
                    this.scale = data[8];
                    this.skinColor = data[9];
                };

                // UPDATE:
                var timerCount = 0;
                this.update = function(delta) {
                    if (!this.alive) return;

                    // UPDATE DATAS
                    this.moveDir = UTILS.getDirection(this.x1, this.y1, this.x2, this.y2);
                    this.weapons[Number(this.weaponIndex > 8)] = this.weaponIndex;
                    if (this.buildIndex == -1) {
                        this.reloads[this.weaponIndex] = Math.max(0, this.reloads[this.weaponIndex] - 1e3 / 9);
                    }
                    this.shootCount = Math.max(0, this.shootCount - 1e3 / 9);
                    this.variants[this.weaponIndex] = config.weaponVariants[this.weaponVariant];
                    this.skin = hats.find(e => e.id == this.skinIndex);
                    this.tail = accessories.find(e => e.id == this.tailIndex);

                    // SHAME SHAME SHAME:
                    if (this.shameTimer > 0) {
                        this.shameTimer -= delta;
                        if (this.shameTimer <= 0) {
                            this.shameTimer = 0;
                            this.shameCount = 0;
                        }
                    }

                    // REGENS AND AUTO:
                    this.timerCount -= delta;
                    if (this.timerCount <= 0) {
                        timerCount = 0;
                    }

                    // SLOWER:
                    if (this.slowMult < 1) {
                        this.slowMult += 0.0008 * delta;
                        if (this.slowMult > 1) this.slowMult = 1;
                    }

                    // MOVE:
                    if (UTILS.getDistance(this.x3, this.y3, this.x2, this.y2) <= 0 || this.lockMove) {
                        this.noMovTimer += delta;
                    } else this.noMovTimer = 0;

                    // OBJECT COLL:
                    this.zIndex = 0;
                    this.lockMove = false;
                    this.healCol = 0;
                    let tmpList = objectManager.getObjects(this.x2, this.y2, this.scale);
                    for (let tmpObj of tmpList) {
                        objectManager.checkCollision(this, tmpObj);
                    }
                };

                // ADD WEAPON XP:
                this.addWeaponXP = function(amount) {
                    if (!this.weaponXP[this.weaponIndex]) this.weaponXP[this.weaponIndex] = 0;
                    this.weaponXP[this.weaponIndex] += amount;
                };

                // EARN XP:
                this.earnXP = function(value) {
                    if (value) {
                        let amount = value - this.XP;
                        if (this.age < config.maxAge) {
                            this.XP += amount;
                        }
                    } else {
                        this.age++;
                        this.XP = 0;
                        this.maxXP *= 1.2;
                        this.upgradePoints++;
                        this.upgradeAge++;
                    }
                };

                // CHANGE HEALTH:
                this.changeHealth = function(value) {
                    let amount = value - this.health;
                    this.health += amount;
                    if (this.health) {
                        if (amount > 0) {
                            if (!this.lastBleed.healed) {
                                if (Date.now() - window.pingTime - this.lastBleed.time <= 120) {
                                    this.shameCount = Math.min(7, this.shameCount + 1);
                                } else {
                                    this.shameCount = Math.max(0, this.shameCount - 2);
                                }
                                this.lastBleed.healed = true;
                            }
                            this.lastHeal.amount = amount;
                            this.lastHeal.time = Date.now() - window.pingTime;
                        } else {
                            this.lastBleed.amount = amount;
                            this.lastBleed.time = Date.now() - window.pingTime;
                            this.lastBleed.healed = false;
                        }
                    } else {
                        this.kill();
                    }
                };

                // KILL:
                this.kill = function() {
                    console.log(this.name + " dead");
                    this.alive = false;
                };

                // ADD RESOURCE:
                this.addResource = function(index, value) {
                    let amount = value - this[index];
                    this[index] += amount;
                    this.addWeaponXP(amount);
                };

                // CHANGE ITEM COUNT:
                this.changeItemCount = function(index, value) {
                    this.itemCounts[index] = this.itemCounts[index] || 0;
                    let amount = value - this.itemCounts[index];
                    this.itemCounts[index] += amount;
                };

                this.buildPosition = function(item, dir) {
                    var tmpS = (this.scale + item.scale + (item.placeOffset || 0));
                    var x = this.x2 + (tmpS * mathCOS(dir));
                    var y = this.y2 + (tmpS * mathSIN(dir));
                    return {
                        x,
                        y
                    };
                }

                // BUILD:
                this.buildItem = function(item, dir) {
                    var tmpS = (this.scale + item.scale + (item.placeOffset || 0));
                    var tmpX = this.x2 + (tmpS * mathCOS(dir));
                    var tmpY = this.y2 + (tmpS * mathSIN(dir));
                    return this.canBuild(item) && (item.consume || objectManager.checkItemLocation(tmpX, tmpY, item.scale, 0.6, item
                                                                                                   .id, false, this));
                };

                // HAS RESOURCES:
                this.hasRes = function(item, mult) {
                    if (config.inSandbox) return true;
                    for (var i = 0; i < item.req.length;) {
                        if (this[item.req[i]] < Math.round(item.req[i + 1] * (mult || 1))) return false;
                        i += 2;
                    }
                    return true;
                };

                // USE RESOURCES:
                this.useRes = function(item, mult) {
                    if (config.inSandbox) return;
                    for (var i = 0; i < item.req.length;) {
                        this.addResource(config.resourceTypes.indexOf(item.req[i]), -Math.round(item.req[i + 1] * (mult || 1)));
                        i += 2;
                    }
                };

                // CAN BUILD:
                this.canBuild = function(item) {
                    if (item.group.limit && this.itemCounts[item.group.id] >= (config.inSandbox ? 99 : item.group.limit))
                        return false;
                    return this.hasRes(item);
                };

                // GATHER:
                this.gather = function(index, didHit) {
                    this.weapons[Number(index > 8)] = index;

                    // SHOW:
                    this.noMovTimer = 0;

                    // SLOW MOVEMENT:
                    this.slowMult -= (items.weapons[this.weaponIndex].hitSlow || 0.3);
                    if (this.slowMult < 0) this.slowMult = 0;


                    pushToTick.push({
                        packet: "33",
                        action: function(sid, index, didHit) {
                            // DEFINE USER
                            let _this = players.find(e => e.sid == sid);

                            _this.lastHit = Date.now() - window.pingTime;

                            // RESET RELOAD
                            _this.reloads[index] = items.weapons[index].speed;

                            // VARIANT DMG:
                            var tmpVariant = _this.variants[index];
                            var applyPoison = tmpVariant.poison;
                            var variantDmg = tmpVariant.val;

                            // WEAPON DAMAGE
                            var damage = items.weapons[index].dmg;
                            var weaponSDmg = (items.weapons[index].sDmg || 1);

                            // HAT DMG MULT
                            var bDmg = (_this.skin?.bDmg || 1);
                            var hatDmgMultO = (_this.skin?.dmgMultO || 1);

                            // TAIL DMG MULT
                            var tailDmgMultO = (_this.tail?.dmgMultO || 1);

                            // CHECK IF HIT GAME OBJECT:
                            var hitObjs = [];
                            var tmpDist, tmpDir;
                            var tmpList = objectManager.getObjects(_this.x2, _this.y2, items.weapons[index].range);
                            if (didHit) {
                                for (let tmpObj of tmpList) {
                                    if (tmpObj.active && Date.now() - window.pingTime - tmpObj.lastWiggle <= 100 && !
                                        tmpObj.dontGather && !hitObjs[tmpObj.sid]) {
                                        tmpDist = UTILS.getDistance(_this.x2, _this.y2, tmpObj.x, tmpObj.y) - tmpObj
                                            .scale;
                                        if (tmpDist <= items.weapons[index].range) {
                                            tmpDir = UTILS.getDirection(tmpObj.x, tmpObj.y, _this.x2, _this.y2);
                                            if (UTILS.getAngleDist(tmpDir, _this.d2) <= config.gatherAngle) {
                                                hitObjs[tmpObj.sid] = 1;
                                                if (tmpObj.health) {
                                                    if (tmpObj.changeHealth(-damage * variantDmg * weaponSDmg * bDmg,
                                                                            _this)) { }
                                                } else {
                                                    var count = items.weapons[index].gather + (tmpObj.type == 3 ? 4 :
                                                                                               0);
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            /*// CHECK IF HIT PLAYER/AI:
for (let i = 0; i < players.length + ais.length; ++i) {
    let tmpObj = players[i] || ais[i - players.length];
    if (tmpObj != _this && tmpObj.alive && Date.now() - window.pingTime - tmpObj.lastBleed.time <= 100 && !(tmpObj.team && tmpObj.team == _this.team)) {
        tmpDist = UTILS.getDistance(_this.x2, _this.y2, tmpObj.x2, tmpObj.y2) - (tmpObj.scale * 1.8);
        if (tmpDist <= items.weapons[index].range) {
            tmpDir = UTILS.getDirection(tmpObj.x2, tmpObj.y2, _this.x2, _this.y2);
            if (UTILS.getAngleDist(tmpDir, _this.d2) <= config.gatherAngle) {

                // STEAL RESOURCES:
                var stealCount = items.weapons[index].steal;
                if (stealCount && tmpObj.addResource) {
                    stealCount = Math.min((tmpObj.points || 0), stealCount);
                }

                // MELEE HIT PLAYER:
                var dmgMlt = variantDmg;
                if (tmpObj.weaponIndex != undefined && items.weapons[tmpObj.weaponIndex].shield &&
                    UTILS.getAngleDist(tmpDir + Math.PI, tmpObj.dir) <= config.shieldAngle) {
                    dmgMlt = items.weapons[tmpObj.weaponIndex].shield;
                }
                var dmgVal = damage * hatDmgMultO * tailDmgMultO;
                var tmpSpd = (0.3 * (tmpObj.weightM || 1)) + (items.weapons[index].knock || 0);
                if (tmpObj.dmgOverTime && _this.skin && _this.skin.poisonDmg && !(tmpObj.skin?.poisonRes)) {
                    tmpObj.dmgOverTime.dmg = _this.skin.poisonDmg;
                    tmpObj.dmgOverTime.time = _this.skin.poisonTime || 1;
                    tmpObj.dmgOverTime.doer = _this;
                }
                if (tmpObj.dmgOverTime && applyPoison && !(tmpObj.skin?.poisonRes)) {
                    tmpObj.dmgOverTime.dmg = 5;
                    tmpObj.dmgOverTime.time = 5;
                    tmpObj.dmgOverTime.doer = this;
                }

            }
        }
    }
}*/
                            return true;
                        },
                        datas: [this.sid, index, didHit],
                    })

                    // SEND FOR ANIMATION:
                    this.startAnim(index, didHit);
                };
                // GATHER ANIMATION:
                this.startAnim = function(didHit, index) {
                    this.animTime = this.animSpeed = items.weapons[index].speed;
                    this.targetAngle = (didHit ? -config.hitAngle : -Math.PI);
                    tmpRatio = 0;
                    animIndex = 0;
                };

                // ANIMATE:
                var tmpRatio = 0;
                var animIndex = 0;
                this.animate = function(delta) {
                    if (this.animTime > 0) {
                        this.animTime -= delta;
                        if (this.animTime <= 0) {
                            this.animTime = 0;
                            this.dirPlus = 0;
                            tmpRatio = 0;
                            animIndex = 0;
                        } else {
                            if (animIndex == 0) {
                                tmpRatio += delta / (this.animSpeed * config.hitReturnRatio);
                                this.dirPlus = UTILS.lerp(0, this.targetAngle, Math.min(1, tmpRatio));
                                if (tmpRatio >= 1) {
                                    tmpRatio = 1;
                                    animIndex = 1;
                                }
                            } else {
                                tmpRatio -= delta / (this.animSpeed * (1 - config.hitReturnRatio));
                                this.dirPlus = UTILS.lerp(0, this.targetAngle, Math.max(0, tmpRatio));
                            }
                        }
                    }
                };

                // CAN SHOT:
                this.canShot = function(other, indx) {
                    if (!other) return false;
                    if (indx == 1 && !this.skins[53] && this.points <= 1e4) return false;
                    let dist = UTILS.getDistance(this.x2, this.y2, other.x2, other.y2);
                    let dir = UTILS.getDirection(other.x2, other.y2, this.x2, this.y2);
                    let projectile = items.projectiles[indx];
                    if (!projectile || projectile.range < dist) return false;
                    let tmpList = objectManager.getObjects(this.x2, this.y2, dist).filter(e =>
                                                                                          UTILS.getAngleDist(dir, UTILS.getDirection(e.x, e.y, this.x2, this.y2)) <= UTILS.toRad(e.getScale()) &&
                                                                                          (indx == 1 && e.id ? e.group.id == 3 || e.id == 17 : true) &&
                                                                                          !e.ignoreCollision);
                    let tmpList2 = players.filter(e =>
                                                  e.sid != this.sid &&
                                                  e.sid != other.sid &&
                                                  UTILS.getAngleDist(dir, UTILS.getDirection(e.x2, e.y2, this.x2, this.y2)) <= UTILS.toRad(e.scale));
                    let tmpList3 = ais.filter(e =>
                                              UTILS.getAngleDist(dir, UTILS.getDirection(e.x2, e.y2, this.x2, this.y2)) <= UTILS.toRad(e.scale));
                    tmpList = [...tmpList, ...tmpList2, ...tmpList3];

                    // HIT OBJECTS:
                    if (tmpList.length > 0) {
                        for (let tmpObj of tmpList) {
                            let x2 = tmpObj[tmpObj.isObject ? "x" : "x2"], y2 = tmpObj[tmpObj.isObject ? "y" : "y2"];
                            let tmpDist = UTILS.getDistance(this.x2, this.y2, x2, y2);
                            let tmpDir = UTILS.getDirection(x2, y2, this.x2, this.y2);
                            let x = this.x2 + Math.cos(dir) * tmpDist,
                                y = this.y2 + Math.sin(dir) * tmpDist;
                            if (UTILS.lineInRect(x2 - tmpObj.scale,
                                                 y2 - tmpObj.scale,
                                                 x2 + tmpObj.scale,
                                                 y2 + tmpObj.scale,
                                                 x, y, x, y)) {
                                return tmpObj;
                            }
                        }
                    }
                    return true;
                };
                // CAN SEE:
                this.canSee = function(other) {
                    if (!other) return false;
                    if (other.skin && other.skin.invisTimer && other.noMovTimer >= other.skin.invisTimer) return false;
                    var dx = Math.abs(other[other.isPlayer || other.isAI ? "x2" : "x"] - this.x2) - other.scale;
                    var dy = Math.abs(other[other.isPlayer || other.isAI ? "y2" : "y"] - this.y2) - other.scale;
                    return dx <= (config.maxScreenWidth / 2) * 1.3 && dy <= (config.maxScreenHeight / 2) * 1.3;
                };

            };
        };
    }),

    "./script/src/js/data/projectile.js": (function(module) {

        module.exports = class {
            constructor(players, ais, objectManager, items, config, UTILS, server) {

                // INIT:
                this.init = function(indx, x, y, dir, spd, dmg, rng, scl, owner) {
                    this.active = true;
                    this.indx = indx;
                    this.x = x;
                    this.y = y;
                    this.dir = dir;
                    this.skipMov = true;
                    this.speed = spd;
                    this.dmg = dmg;
                    this.scale = scl;
                    this.range = rng;
                    this.owner = owner;
                };

                // UPDATE:
                var objectsHit = [];
                var tmpObj;
                this.update = function(delta) {
                    if (this.active) {
                        var tmpSpeed = this.speed * delta;
                        var tmpScale;
                        if (!this.skipMov) {
                            this.x += tmpSpeed * Math.cos(this.dir);
                            this.y += tmpSpeed * Math.sin(this.dir);
                            this.range -= tmpSpeed;
                            if (this.range <= 0) {
                                this.x += this.range * Math.cos(this.dir);
                                this.y += this.range * Math.sin(this.dir);
                                tmpSpeed = 1;
                                this.range = 0;
                                this.active = false;
                            }
                        } else {
                            this.skipMov = false;
                        }
                        objectsHit.length = 0;
                        for (let i = 0; i < players.length + ais.length; ++i) {
                            tmpObj = players[i] || ais[i - players.length];
                            if (tmpObj.alive && tmpObj.sid != this.owner.sid) {
                                if (UTILS.lineInRect(tmpObj.x2 - tmpObj.scale,
                                                     tmpObj.y2 - tmpObj.scale,
                                                     tmpObj.x2 + tmpObj.scale,
                                                     tmpObj.y2 + tmpObj.scale,
                                                     this.x,
                                                     this.y,
                                                     this.x + (tmpSpeed * Math.cos(this.dir)),
                                                     this.y + (tmpSpeed * Math.sin(this.dir)),
                                                    )) {
                                    objectsHit.push(tmpObj);
                                }
                            }
                        }
                        var tmpList = objectManager.getObjects(this.x, this.y, this.scale);
                        for (var x = 0; x < tmpList.length; ++x) {
                            for (var y = 0; y < tmpList[x].length; ++y) {
                                tmpObj = tmpList[x][y];
                                tmpScale = tmpObj.getScale();
                                if (tmpObj.active && !(this.ignoreObj == tmpObj.sid) && (this.layer <= tmpObj.layer) &&
                                    objectsHit.indexOf(tmpObj) < 0 && !tmpObj.ignoreCollision && UTILS.lineInRect(tmpObj.x -
                                                                                                                  tmpScale,
                                                                                                                  tmpObj.y - tmpScale,
                                                                                                                  tmpObj.x + tmpScale,
                                                                                                                  tmpObj.y + tmpScale,
                                                                                                                  this.x,
                                                                                                                  this.y,
                                                                                                                  this.x + (tmpSpeed * Math.cos(this.dir)),
                                                                                                                  this.y + (tmpSpeed * Math.sin(this.dir)),
                                                                                                                 )) {
                                    objectsHit.push(tmpObj);
                                }
                            }
                        }

                        // HIT OBJECTS:
                        if (objectsHit.length > 0) {
                            var hitObj = null;
                            var shortDist = null;
                            var tmpDist = null;
                            for (let i = 0; i < objectsHit.length; ++i) {
                                tmpDist = UTILS.getDistance(this.x, this.y, objectsHit[i].x, objectsHit[i].y);
                                if (shortDist == null || tmpDist < shortDist) {
                                    shortDist = tmpDist;
                                    hitObj = objectsHit[i];
                                }
                            }
                            if (hitObj.isPlayer || hitObj.isAI) {
                                /*var tmpSd = 0.3 * (hitObj.weightM || 1);
if (hitObj.weaponIndex == undefined || (!(items.weapons[hitObj.weaponIndex].shield &&
                                          UTILS.getAngleDist(this.dir + Math.PI, hitObj.dir) <= config.shieldAngle))) {
    hitObj.changeHealth(-this.dmg, this.owner, this.owner);
}*/
                            } else {
                                if (hitObj.projDmg && hitObj.health && hitObj.changeHealth(-this.dmg)) { }
                                for (let i = 0; i < players.length; ++i) {
                                    if (players[i].active) {
                                        if (hitObj.sentTo[players[i].id]) {
                                            if (hitObj.active) { } else { }
                                        }
                                        if (!hitObj.active && hitObj.owner == players[i]) { }
                                    }

                                }
                            }
                            this.active = false;
                        }
                    }
                };
            };
        };
    }),

    "./script/src/js/data/projectileManager.js": (function(module) {

        module.exports = class {
            constructor(Projectile, projectiles, players, ais, objectManager, items, config, UTILS, server) {
                this.addProjectile = function(x, y, dir, range, speed, indx, owner, ignoreObj, layer, sid) {
                    var projOffset = 70;
                    var tmpData = items.projectiles[indx];
                    var tmpProj;
                    for (var i = 0; i < projectiles.length; ++i) {
                        if (!projectiles[i].active) {
                            tmpProj = projectiles[i];
                            break;
                        }
                    }
                    pushToTick.push({
                        packet: "33",
                        action: function(x, y, dir, range, speed, indx, owner, ignoreObj, layer, sid, tmpData, tmpProj) {
                            let x2 = x - Math.cos(dir) * 70;
                            let y2 = y - Math.sin(dir) * 70;
                            if (!tmpProj) {
                                tmpProj = new Projectile(players, ais, objectManager, items, config, UTILS, server);
                                tmpProj.sid = sid;
                                projectiles.push(tmpProj);
                            }
                            owner = players.find(e => e.visible && (indx == 1 ? e.skinIndex == 53 : items.weapons[e
                                                                                                                  .weaponIndex].projectile == indx) && UTILS.getDistance(e.x2, e.y2, x2, y2) <=
                                                 35 + (indx == 5 ? 42.5 : 35));
                            owner && (indx == 1 ? owner.shootCount = 25e2 : owner.reloads[owner.weaponIndex] = items
                                      .weapons[owner.weaponIndex].speed);
                            tmpProj.init(indx, x, y, dir, speed, tmpData.dmg, range, tmpData.scale, owner ? owner.sid :
                                         null);
                            tmpProj.ignoreObj = ignoreObj;
                            tmpProj.layer = layer || tmpData.layer;
                            tmpProj.src = tmpData.src;
                            return true;
                        },
                        datas: [x, y, dir, range, speed, indx, owner, ignoreObj, layer, sid, tmpData, tmpProj],
                    });
                };
            };
        };
    }),
    "./script/src/js/data/store.js": (function(module) {


        // STORE HATS:
        module.exports.hats = [{
            id: 45,
            name: "Shame!",
            dontSell: true,
            price: 0,
            scale: 120,
            desc: "hacks are for losers"
        }, {
            id: 51,
            name: "Moo Cap",
            price: 0,
            scale: 120,
            desc: "coolest mooer around"
        }, {
            id: 50,
            name: "Apple Cap",
            price: 0,
            scale: 120,
            desc: "apple farms remembers"
        }, {
            id: 28,
            name: "Moo Head",
            price: 0,
            scale: 120,
            desc: "no effect"
        }, {
            id: 29,
            name: "Pig Head",
            price: 0,
            scale: 120,
            desc: "no effect"
        }, {
            id: 30,
            name: "Fluff Head",
            price: 0,
            scale: 120,
            desc: "no effect"
        }, {
            id: 36,
            name: "Pandou Head",
            price: 0,
            scale: 120,
            desc: "no effect"
        }, {
            id: 37,
            name: "Bear Head",
            price: 0,
            scale: 120,
            desc: "no effect"
        }, {
            id: 38,
            name: "Monkey Head",
            price: 0,
            scale: 120,
            desc: "no effect"
        }, {
            id: 44,
            name: "Polar Head",
            price: 0,
            scale: 120,
            desc: "no effect"
        }, {
            id: 35,
            name: "Fez Hat",
            price: 0,
            scale: 120,
            desc: "no effect"
        }, {
            id: 42,
            name: "Enigma Hat",
            price: 0,
            scale: 120,
            desc: "join the enigma army"
        }, {
            id: 43,
            name: "Blitz Hat",
            price: 0,
            scale: 120,
            desc: "hey everybody i'm blitz"
        }, {
            id: 49,
            name: "Bob XIII Hat",
            price: 0,
            scale: 120,
            desc: "like and subscribe"
        }, {
            id: 57,
            name: "Pumpkin",
            price: 50,
            scale: 120,
            desc: "Spooooky"
        }, {
            id: 8,
            name: "Bummle Hat",
            price: 100,
            scale: 120,
            desc: "no effect"
        }, {
            id: 2,
            name: "Straw Hat",
            price: 500,
            scale: 120,
            desc: "no effect"
        }, {
            id: 15,
            name: "Winter Cap",
            price: 600,
            scale: 120,
            desc: "allows you to move at normal speed in snow",
            coldM: 1
        }, {
            id: 5,
            name: "Cowboy Hat",
            price: 1000,
            scale: 120,
            desc: "no effect"
        }, {
            id: 4,
            name: "Ranger Hat",
            price: 2000,
            scale: 120,
            desc: "no effect"
        }, {
            id: 18,
            name: "Explorer Hat",
            price: 2000,
            scale: 120,
            desc: "no effect"
        }, {
            id: 31,
            name: "Flipper Hat",
            price: 2500,
            scale: 120,
            desc: "have more control while in water",
            watrImm: true
        }, {
            id: 1,
            name: "Marksman Cap",
            price: 3000,
            scale: 120,
            desc: "increases arrow speed and range",
            aMlt: 1.3
        }, {
            id: 10,
            name: "Bush Gear",
            price: 3000,
            scale: 160,
            desc: "allows you to disguise yourself as a bush"
        }, {
            id: 48,
            name: "Halo",
            price: 3000,
            scale: 120,
            desc: "no effect"
        }, {
            id: 6,
            name: "Soldier Helmet",
            price: 4000,
            scale: 120,
            desc: "reduces damage taken but slows movement",
            spdMult: 0.94,
            dmgMult: 0.75
        }, {
            id: 23,
            name: "Anti Venom Gear",
            price: 4000,
            scale: 120,
            desc: "makes you immune to poison",
            poisonRes: 1
        }, {
            id: 13,
            name: "Medic Gear",
            price: 5000,
            scale: 110,
            desc: "slowly regenerates health over time",
            healthRegen: 3
        }, {
            id: 9,
            name: "Miners Helmet",
            price: 5000,
            scale: 120,
            desc: "earn 1 extra gold per resource",
            extraGold: 1
        }, {
            id: 32,
            name: "Musketeer Hat",
            price: 5000,
            scale: 120,
            desc: "reduces cost of projectiles",
            projCost: 0.5
        }, {
            id: 7,
            name: "Bull Helmet",
            price: 6000,
            scale: 120,
            desc: "increases damage done but drains health",
            healthRegen: -5,
            dmgMultO: 1.5,
            spdMult: 0.96
        }, {
            id: 22,
            name: "Emp Helmet",
            price: 6000,
            scale: 120,
            desc: "turrets won't attack but you move slower",
            antiTurret: 1,
            spdMult: 0.7
        }, {
            id: 12,
            name: "Booster Hat",
            price: 6000,
            scale: 120,
            desc: "increases your movement speed",
            spdMult: 1.16
        }, {
            id: 26,
            name: "Barbarian Armor",
            price: 8000,
            scale: 120,
            desc: "knocks back enemies that attack you",
            dmgK: 0.6
        }, {
            id: 21,
            name: "Plague Mask",
            price: 10000,
            scale: 120,
            desc: "melee attacks deal poison damage",
            poisonDmg: 5,
            poisonTime: 6
        }, {
            id: 46,
            name: "Bull Mask",
            price: 10000,
            scale: 120,
            desc: "bulls won't target you unless you attack them",
            bullRepel: 1
        }, {
            id: 14,
            name: "Windmill Hat",
            topSprite: true,
            price: 10000,
            scale: 120,
            desc: "generates points while worn",
            pps: 1.5
        }, {
            id: 11,
            name: "Spike Gear",
            topSprite: true,
            price: 10000,
            scale: 120,
            desc: "deal damage to players that damage you",
            dmg: 0.45
        }, {
            id: 53,
            name: "Turret Gear",
            topSprite: true,
            price: 10000,
            scale: 120,
            desc: "you become a walking turret",
            turret: {
                proj: 1,
                range: 700,
                rate: 2500
            },
            spdMult: 0.7
        }, {
            id: 20,
            name: "Samurai Armor",
            price: 12000,
            scale: 120,
            desc: "increased attack speed and fire rate",
            atkSpd: 0.78
        }, {
            id: 58,
            name: "Dark Knight",
            price: 12000,
            scale: 120,
            desc: "restores health when you deal damage",
            healD: 0.4
        }, {
            id: 27,
            name: "Scavenger Gear",
            price: 15000,
            scale: 120,
            desc: "earn double points for each kill",
            kScrM: 2
        }, {
            id: 40,
            name: "Tank Gear",
            price: 15000,
            scale: 120,
            desc: "increased damage to buildings but slower movement",
            spdMult: 0.3,
            bDmg: 3.3
        }, {
            id: 52,
            name: "Thief Gear",
            price: 15000,
            scale: 120,
            desc: "steal half of a players gold when you kill them",
            goldSteal: 0.5
        }, {
            id: 55,
            name: "Bloodthirster",
            price: 20000,
            scale: 120,
            desc: "Restore Health when dealing damage. And increased damage",
            healD: 0.25,
            dmgMultO: 1.2,
        }, {
            id: 56,
            name: "Assassin Gear",
            price: 20000,
            scale: 120,
            desc: "Go invisible when not moving. Can't eat. Increased speed",
            noEat: true,
            spdMult: 1.1,
            invisTimer: 1000
        }];

        // STORE ACCESSORIES:
        module.exports.accessories = [{
            id: 12,
            name: "Snowball",
            price: 1000,
            scale: 105,
            xOff: 18,
            desc: "no effect"
        }, {
            id: 9,
            name: "Tree Cape",
            price: 1000,
            scale: 90,
            desc: "no effect"
        }, {
            id: 10,
            name: "Stone Cape",
            price: 1000,
            scale: 90,
            desc: "no effect"
        }, {
            id: 3,
            name: "Cookie Cape",
            price: 1500,
            scale: 90,
            desc: "no effect"
        }, {
            id: 8,
            name: "Cow Cape",
            price: 2000,
            scale: 90,
            desc: "no effect"
        }, {
            id: 11,
            name: "Monkey Tail",
            price: 2000,
            scale: 97,
            xOff: 25,
            desc: "Super speed but reduced damage",
            spdMult: 1.35,
            dmgMultO: 0.2
        }, {
            id: 17,
            name: "Apple Basket",
            price: 3000,
            scale: 80,
            xOff: 12,
            desc: "slowly regenerates health over time",
            healthRegen: 1
        }, {
            id: 6,
            name: "Winter Cape",
            price: 3000,
            scale: 90,
            desc: "no effect"
        }, {
            id: 4,
            name: "Skull Cape",
            price: 4000,
            scale: 90,
            desc: "no effect"
        }, {
            id: 5,
            name: "Dash Cape",
            price: 5000,
            scale: 90,
            desc: "no effect"
        }, {
            id: 2,
            name: "Dragon Cape",
            price: 6000,
            scale: 90,
            desc: "no effect"
        }, {
            id: 1,
            name: "Super Cape",
            price: 8000,
            scale: 90,
            desc: "no effect"
        }, {
            id: 7,
            name: "Troll Cape",
            price: 8000,
            scale: 90,
            desc: "no effect"
        }, {
            id: 14,
            name: "Thorns",
            price: 10000,
            scale: 115,
            xOff: 20,
            desc: "no effect"
        }, {
            id: 15,
            name: "Blockades",
            price: 10000,
            scale: 95,
            xOff: 15,
            desc: "no effect"
        }, {
            id: 20,
            name: "Devils Tail",
            price: 10000,
            scale: 95,
            xOff: 20,
            desc: "no effect"
        }, {
            id: 16,
            name: "Sawblade",
            price: 12000,
            scale: 90,
            spin: true,
            xOff: 0,
            desc: "deal damage to players that damage you",
            dmg: 0.15
        }, {
            id: 13,
            name: "Angel Wings",
            price: 15000,
            scale: 138,
            xOff: 22,
            desc: "slowly regenerates health over time",
            healthRegen: 3
        }, {
            id: 19,
            name: "Shadow Wings",
            price: 15000,
            scale: 138,
            xOff: 22,
            desc: "increased movement speed",
            spdMult: 1.1
        }, {
            id: 18,
            name: "Blood Wings",
            price: 20000,
            scale: 178,
            xOff: 26,
            desc: "restores health when you deal damage",
            healD: 0.2
        }, {
            id: 21,
            name: "Corrupt X Wings",
            price: 20000,
            scale: 178,
            xOff: 26,
            desc: "deal damage to players that damage you",
            dmg: 0.25
        }];
    }),
    "./script/src/js/libs/io-client.js": (function(module) {
        module.exports = {
            socket: null,
            connected: false,
            socketId: -1,
            connect: function(socket, callback, events, aCC) {
                if (this.socket) return;

                // CREATE SOCKET:
                var _this = this;
                try {
                    var socketError = false;
                    this.socket = socket;
                    this.socket.binaryType = "arraybuffer";
                    this.socket.addEventListener("message", function(message) {
                        // PARSE MESSAGE:
                        let [packet, datas] = msgpack.decode(new Uint8Array(message.data));
                        // CALL EVENT:
                        if (packet == "io-init") {
                            _this.socketId = datas[0];
                        }
                        packet == "33" && aCC.resetCalculator();
                        events[packet](...datas);
                    });
                    this.socket.onopen = function() {
                        _this.connected = true;
                    };
                    this.socket.onclose = function(event) {
                        _this.connected = false;
                        if (event.code == 4001) {
                            console.error("Invalid Connection");
                        } else if (!socketError) {
                            console.error("disconnected");
                        }
                    };
                    this.socket.onerror = function(error) {
                        if (this.socket && this.socket.readyState != WebSocket.OPEN) {
                            socketError = true;
                            console.error("Socket error", arguments);
                        }
                    };
                } catch (e) {
                    console.warn("Socket connection error:", e);
                }
            },
            send: function(type) {
                // EXTRACT DATA ARRAY:
                var data = Array.prototype.slice.call(arguments, 1);

                // SEND MESSAGE:
                var binary = msgpack.encode([type, data, true]);
                this.socket.send(binary);
            },
            socketReady: function() {
                return (this.socket && this.connected);
            },
            close: function() {
                this.socket && this.socket.close();
            }
        };

    }),
    "./script/src/js/app.js": (function(module) {
        module.exports.run = function() {
            let informationMenu = Object.assign(document.createElement("div"), {
                id: "informationMenu",
                borderRadius: "4px",
                textAlign: "left",
            });
            Object.assign(informationMenu.style, {
                position: "absolute",
                color: "white",
                width: "200px",
                height: "326px",
                top: "20px",
                right: "20px"
            });
            document.getElementById("gameUI").appendChild(informationMenu);
            informationMenu.style.display = "block";
            setInterval(() => {
                let songName = singing.name?.split(" - ")[1];
                let newName = "";
                if (songName?.length) {
                    for (let i = 0; i < songName.length; i++) {
                        if (i > 15) {
                            newName += "...";
                            break;
                        } else {
                            newName += songName[i];
                        }
                    }
                }
                informationMenu.innerHTML = `
                        <div style="font-size: 14px;">
                        Ping: ${window.pingTime}<br>
                        Auto-Insta: ${instakill?.toggle ? "ON" : "OFF"}<br>
                        Auto-Mill: ${autoMill?.toggle ? "ON" : "OFF"}<br>
                        Music: ${singing?.toggle ? "ON" : "OFF"}<br>
                        ${singing?.toggle ? `
                        .singer: ${singing.name.split(" - ")[0]}<br>
                        .name: ${newName}<br>
                        .currentTime: ${Math.ceil(singing?.audio?.currentTime || 0)}<br>` : ""}
                        </div>`;
            });
            __webpack_require__("./script/src/js/libs/modernizr.js").run();

            var isProd = location.hostname !== "127.0.0.1" && !location.hostname.startsWith("192.168.");

            var antiCheatCalculator = __webpack_require__("./script/src/js/libs/antiCheatCalculator.js");
            var io = __webpack_require__("./script/src/js/libs/io-client.js");
            var UTILS = __webpack_require__("./script/src/js/libs/utils.js");
            var config = __webpack_require__("./script/src/js/config.js");
            var GameObject = __webpack_require__("./script/src/js/data/gameObject.js");
            var items = __webpack_require__("./script/src/js/data/items.js");
            var ObjectManager = __webpack_require__("./script/src/js/data/objectManager.js");
            var Player = __webpack_require__("./script/src/js/data/player.js");
            var store = __webpack_require__("./script/src/js/data/store.js");
            var Projectile = __webpack_require__("./script/src/js/data/projectile.js");
            var ProjectileManager = __webpack_require__("./script/src/js/data/projectileManager.js");
            var AiManager = __webpack_require__("./script/src/js/data/aiManager.js");
            var AI = __webpack_require__("./script/src/js/data/ai.js");
            // VULTR:
            vultrClient.debugLog = false;
            var didLoad = false;
            window._onload = window.onload;
            window.onload = function() {
                didLoad = true;
                //connectSocketIfReady();
                this._onload();
            };

            // URL PARAMS:
            function getParameterByName(name, url) {
                if (!url) {
                    url = window.location.href;
                }
                name = name.replace(/[\[\]]/g, "\\$&");
                var regex = new RegExp("[?&]" + name + "(=([^&#]*)|&|#|$)"),
                    results = regex.exec(url);
                if (!results) return null;
                if (!results[2]) return '';
                return decodeURIComponent(results[2].replace(/\+/g, " "));
            }

            // SOCKET & CONNECTION:
            var connected = false;
            var startedConnecting = false;

            function connectSocketIfReady() {
                // MAKE SURE IT'S READY:
                if (!didLoad) return;
                startedConnecting = true;

                // GET TOKEN:
                if (isProd) {
                    window.grecaptcha.execute("6LevKusUAAAAAAFknhlV8sPtXAk5Z5dGP5T2FYIZ", {
                        action: "homepage"
                    }).then(function(token) {
                        // CONNECT SOCKET:
                        connectSocket(token);
                    });
                } else {
                    // CONNECT SOCKET:
                    connectSocket(null);
                }
            }

            function connectSocket(ws) {
                // CONNECT SOCKET:
                /*vultrClient.start(function(address, port, gameIndex) {
    // CREATE ADDRESS:
    var protocol = isProd ? "wss" : "ws";
    var wsAddress = protocol + "://" + address + ":" + 8008 + "/?gameIndex=" + gameIndex;
    if (token) wsAddress += "&token=" + encodeURIComponent(token);
}, function(error) {
    console.error("Vultr error:", error);
    alert("Error:\n" + error);
    disconnect("disconnected");
});*/

                // CONNECT:
                io.connect(ws, function(error) {
                    //pingSocket();
                    //setInterval(() => pingSocket(), 2500);

                    if (error) {
                        disconnect(error);
                    } else {
                        //connected = true;
                        //startGame();
                    }
                }, {
                    "io-init": io_init,
                    "id": setInitData,
                    "d": disconnect,
                    "1": setupGame,
                    "2": addPlayer,
                    "4": removePlayer,
                    "33": updatePlayers,
                    "5": updateLeaderboard,
                    "6": loadGameObject,
                    "a": loadAI,
                    "aa": animateAI,
                    "7": gatherAnimation,
                    "8": wiggleGameObject,
                    "sp": shootTurret,
                    "9": updatePlayerValue,
                    "h": updateHealth,
                    "11": killPlayer,
                    "12": killObject,
                    "13": killObjects,
                    "14": updateItemCounts,
                    "15": updateAge,
                    "16": updateUpgrades,
                    "17": updateItems,
                    "18": addProjectile,
                    "19": removeProjectile,
                    "20": serverShutdownNotice,
                    "ac": addAlliance,
                    "ad": deleteAlliance,
                    "an": allianceNotification,
                    "st": setPlayerTeam,
                    "sa": setAlliancePlayers,
                    "us": updateStoreItems,
                    "ch": receiveChat,
                    "mm": updateMinimap,
                    "t": showText,
                    "p": pingMap,
                    "pp": pingSocketResponse
                }, antiCheatCalculator);
            }


            var useNativeResolution;
            var showPing;
            var playSound;
            var pixelDensity = 1;
            var delta, now, lastSent;
            var lastUpdate = Date.now();
            var keys, attackState;
            var ais = [];
            var players = [];
            var alliances = [];
            var gameObjects = [];
            var projectiles = [];
            var objectManager = new ObjectManager(GameObject, gameObjects, UTILS, config, items, Projectile, players);
            var projectileManager = new ProjectileManager(Projectile, projectiles, players, ais, objectManager, items, config, UTILS);
            var aiManager = new AiManager(ais, AI, players, items, objectManager, config, UTILS);
            var player, playerSID, tmpObj;
            var waterMult = 1;
            var waterPlus = 0;
            var mouseX = 0;
            var mouseY = 0;
            var controllingTouch = {
                id: -1,
                startX: 0,
                startY: 0,
                currentX: 0,
                currentY: 0
            };
            var attackingTouch = {
                id: -1,
                startX: 0,
                startY: 0,
                currentX: 0,
                currentY: 0
            };
            var camX, camY;
            var tmpDir;
            var skinColor = 0;
            var maxScreenWidth = config.maxScreenWidth;
            var maxScreenHeight = config.maxScreenHeight;
            var screenWidth, screenHeight;
            var inGame = false;
            var adContainer = document.getElementById("ad-container");
            var mainMenu = document.getElementById("mainMenu");
            var enterGameButton = document.getElementById("enterGame");
            var promoImageButton = document.getElementById("promoImg");
            var partyButton = document.getElementById("partyButton");
            var joinPartyButton = document.getElementById("joinPartyButton");
            var settingsButton = document.getElementById("settingsButton");
            var settingsButtonTitle = settingsButton.getElementsByTagName("span")[0];
            var allianceButton = document.getElementById("allianceButton");
            var storeButton = document.getElementById("storeButton");
            var chatButton = document.getElementById("chatButton");
            var gameCanvas = document.getElementById("gameCanvas");
            var mainContext = gameCanvas.getContext("2d");
            var serverBrowser = document.getElementById("serverBrowser");
            var nativeResolutionCheckbox = document.getElementById("nativeResolution");
            var showPingCheckbox = document.getElementById("showPing");
            var playMusicCheckbox = document.getElementById("playMusic");
            var pingDisplay = document.getElementById("pingDisplay");
            var shutdownDisplay = document.getElementById("shutdownDisplay");
            var menuCardHolder = document.getElementById("menuCardHolder");
            var guideCard = document.getElementById("guideCard");
            var loadingText = document.getElementById("loadingText");
            var gameUI = document.getElementById("gameUI");
            var actionBar = document.getElementById("actionBar");
            var scoreDisplay = document.getElementById("scoreDisplay");
            var foodDisplay = document.getElementById("foodDisplay");
            var woodDisplay = document.getElementById("woodDisplay");
            var stoneDisplay = document.getElementById("stoneDisplay");
            var killCounter = document.getElementById("killCounter");
            var leaderboardData = document.getElementById("leaderboardData");
            var chatBox = document.getElementById("chatBox");
            var chatHolder = document.getElementById("chatHolder");
            $("#topInfoHolder").css({
                left: "20px",
                display: "none",
            });
            $("#scoreDisplay").css({
                "background-image": "url(../img/resources/gold_ico.png)",
                "background-position": "right 6px center",
                right: "20px",
                bottom: "240px",
                "padding-left": "10px",
                "padding-right": "40px",
                left: "inherit",
            });
            document.getElementById("resDisplay").appendChild(killCounter);
            $("#killCounter").css({
                bottom: "185px",
                right: "20px",
                display: "block",
            });
            $("#storeButton").css({
                left: "425px",
                width: "40px",
            });
            $("#allianceButton").css({
                left: "425px",
                top: "80px",
                width: "40px",
            });
            $("#chatButton").remove();
            var nameInput = document.getElementById("nameInput");
            var itemInfoHolder = document.getElementById("itemInfoHolder");
            var ageText = document.getElementById("ageText");
            var ageBarBody = document.getElementById("ageBarBody");
            var upgradeHolder = document.getElementById("upgradeHolder");
            var upgradeCounter = document.getElementById("upgradeCounter");
            var allianceMenu = document.getElementById("allianceMenu");
            var allianceHolder = document.getElementById("allianceHolder");
            var allianceManager = document.getElementById("allianceManager");
            var mapDisplay = document.getElementById("mapDisplay");
            var diedText = document.getElementById("diedText");
            var skinColorHolder = document.getElementById("skinColorHolder");
            var mapContext = mapDisplay.getContext("2d");
            var storeMenu = document.getElementById("storeMenu");
            var storeHolder = document.getElementById("storeHolder");
            var noticationDisplay = document.getElementById("noticationDisplay");
            var outlineColor = "#525252";
            var darkOutlineColor = "#3d3f42";
            var outlineWidth = 5.5;

            var allianceNotifications = [];
            var alliancePlayers = [];

            var minimapData;
            var mapPings = [];
            var tmpPing;
            class MapPing {
                constructor() {
                    this.init = function(x, y) {
                        this.scale = 0;
                        this.x = x;
                        this.y = y;
                        this.active = true;
                    };
                    this.update = function(ctxt, delta) {
                        if (this.active) {
                            this.scale += 0.05 * delta;
                            if (this.scale >= config.mapPingScale) {
                                this.active = false;
                            } else {
                                ctxt.globalAlpha = (1 - Math.max(0, this.scale / config.mapPingScale));
                                ctxt.beginPath();
                                ctxt.arc((this.x / config.mapScale) * mapDisplay.width, (this.y / config.mapScale) *
                                         mapDisplay.width, this.scale, 0, 2 * Math.PI);
                                ctxt.stroke();
                            }
                        }
                    };
                }
            }
            var modules = {
                mirrorChat: {
                    name: "Mirror Chat",
                    category: "main",
                    type: "checkbox",
                    default: false,
                },
                autoSpawn: {
                    name: "Auto Spawn",
                    category: "main",
                    type: "checkbox",
                    default: false,
                },
                songChats: {
                    name: "Song: ",
                    category: "main",
                    type: "option",
                },
                loadTexture: {
                    name: "Load Texture: ",
                    category: "main",
                    type: "file",
                    default: [],
                },
                textures: {
                    name: "Textures: ",
                    category: "main",
                    type: "option",
                },
                autoDamager: {
                    name: "Auto Damager",
                    category: "offense",
                    type: "checkbox",
                    default: true,
                },
                autoInstakill: {
                    name: "Auto Insta Kill",
                    category: "offense",
                    type: "checkbox",
                    default: true,
                },
                blockAutoInstakillWhileClicking: {
                    name: "Block Auto Instakill While Clicking (Only if Auto Insta Kill enabled)",
                    category: "offense",
                    type: "checkbox",
                    default: true,
                },
                autoPlacer: {
                    name: "Auto Placer",
                    category: "offense",
                    type: "checkbox",
                    default: true,
                },
                autoReplacer: {
                    name: "Auto Replacer",
                    category: "offense",
                    type: "checkbox",
                    default: true,
                },
                autoKillerHit: {
                    name: "Auto Killer Hit",
                    category: "offense",
                    type: "checkbox",
                    default: true,
                },
                autoKillerShot: {
                    name: "Auto Killer Shot",
                    category: "offense",
                    type: "checkbox",
                    default: true,
                },
                autoKillerSpike: {
                    name: "Auto Killer Spike",
                    category: "offense",
                    type: "checkbox",
                    default: true,
                },
                antiTrap: {
                    name: "Anti Trap",
                    category: "defense",
                    type: "checkbox",
                    default: true,
                },
                autoShameReseter: {
                    name: "Auto Shame Reseter",
                    category: "support",
                    type: "checkbox",
                    default: true,
                },
                autoTrapBreaker: {
                    name: "Auto Trap Breaker",
                    category: "support",
                    type: "checkbox",
                    default: true,
                },
                autoTrapBreakerModes: {
                    name: "Auto Trap Breaker Modes: ",
                    category: "support",
                    type: "option",
                    options: [{
                        id: "normal",
                    }, {
                        id: "defensive",
                    }, {
                        id: "offensive",
                    }],
                    default: "normal",
                },
                fullSoldierOnAutoTrapBreaker: {
                    name: "Full Soldier On Auto Trap Breaker",
                    category: "support",
                    type: "checkbox",
                    default: false,
                },
                autoHeal: {
                    name: "Auto Heal",
                    category: "support",
                    type: "checkbox",
                    default: true,
                },
                antiInsta: {
                    name: "Anti Insta",
                    category: "defense",
                    type: "checkbox",
                    default: true,
                },
                antiLowHealth: {
                    name: "Auto Low Health",
                    category: "defense",
                    type: "checkbox",
                    default: true,
                },
                autoWeaponCharger: {
                    name: "Auto Weapon Charger",
                    category: "support",
                    type: "checkbox",
                    default: true,
                },
                autoBiomeHat: {
                    name: "Auto Biome Hat",
                    category: "support",
                    type: "checkbox",
                    default: true,
                },
                autoSoldier: {
                    name: "Auto Soldier",
                    category: "defense",
                    type: "checkbox",
                    default: true,
                },
                autoSoldierInRiver: {
                    name: "Auto Soldier In River (Only if Auto Soldier enabled)",
                    category: "defense",
                    type: "checkbox",
                    default: false,
                },
                autoEmp: {
                    name: "Auto Emp",
                    category: "defense",
                    type: "checkbox",
                    default: true,
                },
                chatOnInstakill: {
                    name: "Chat On Insta Kill",
                    category: "chat",
                    type: "text",
                    default: "",
                },
                instakillHotkey: {
                    name: "Insta Kill Hotkey",
                    category: "hotkey",
                    type: "text",
                    default: "r",
                },
                autoMillHotkey: {
                    name: "Auto Mill Hotkey",
                    category: "hotkey",
                    type: "text",
                    default: "n",
                },
                autoGrindHotkey: {
                    name: "Auto Grind Hotkey",
                    category: "hotkey",
                    type: "text",
                    default: "b",
                },
                healHotkey: {
                    name: "Heal Hotkey",
                    category: "hotkey",
                    type: "text",
                    default: "q",
                },
                spikeHotkey: {
                    name: "Spike Hotkey",
                    category: "hotkey",
                    type: "text",
                    default: "v",
                },
                trapHotkey: {
                    name: "Trap Hotkey",
                    category: "hotkey",
                    type: "text",
                    default: "f",
                },
                turretHotkey: {
                    name: "Turret Hotkey",
                    category: "hotkey",
                    type: "text",
                    default: "h",
                },
            };
            var singing = {
                audio: null,
                name: "",
                toggle: false,
                start: 0,
                stop: 0,
                index: 0,
            };
            var songs = [{
                name: "Egzod - No Rival",
                src: "https://cdn.discordapp.com/attachments/1059159650026659842/1075173234263203861/Egzod_Maestro_Chives_Alaina_Cross_-_No_Rival_NCS_Release.mp3",
                sync: {
                    "12:679": "Here and now",
                    "13:730": "you're coming up to me",
                    "15:197": "'Fore I'm lighting up the sky",
                    "18:565": "Feel the ground",
                    "19:855": "shaking underneath",
                    "21:346": "Tryna take me alive",
                    "24:415": "Oh-oh-oh-oh-oh-oh-oh",
                    "26:906": "Get ready for the fallout",
                    "30:357": "Oh-oh-oh-oh-oh-oh-oh",
                    "33:26": "Can't stop me now",
                    "35:154": "I got no rival",
                    "37:463": "I'ma find my way",
                    "39:615": "Through the blood and pain",
                    "41:162": "Game of survival",
                    "43:463": "Any time or place",
                    "45:577": "Watch 'em run away",
                    "47:337": "I got no-",
                    "49:78": "I'll be standing on my own",
                    "51:259": "Never gonna take my thrown",
                    "53:389": "I got no rival",
                    "55:349": "Watch 'em run away",
                    "57:320": "I got no, no, no",
                    "58:789": "I got no, no, no rival",
                    "1:0:227": "No rival",
                    "1:11:329": "No rival",
                    "1:17:295": "No Rival",
                    "1:24:694": "Tell them now what you gon' do",
                    "1:27:265": "We can do this face-to-face",
                    "1:30:316": "Reckoning is coming real soon",
                    "1:33:254": "Doesn't matter what you say",
                    "1:36:175": "Tryna tell you",
                    "1:37:203": "listen to the moment",
                    "1:38:512": "Can't take mine 'cause I own it",
                    "1:42:714": "Don't you know that",
                    "1:43:869": "I'm locked and I'm loaded?",
                    "1:45:389": "You're out of focus",
                    "1:48:202": "Oh-oh-oh-oh-oh-oh-oh",
                    "1:51:61": "Get ready for the fallout",
                    "1:54:362": "Oh-oh-oh-oh-oh-oh-oh",
                    "1:56:885": "Can't stop me now",
                    "1:59:205": "I got no rival",
                    "2:1:383": "I'ma find my way",
                    "2:3:722": "Through the blood and pain",
                    "2:5:242": "Game of survival",
                    "2:7:461": "Any time or place",
                    "2:9:631": "Watch 'em run away",
                    "2:11:210": "I got no-",
                    "2:12:959": "I'll be standing on my own",
                    "2:15:221": "Never gonna take my throne",
                    "2:17:141": "I got no rival",
                    "2:19:351": "Watch 'em run away",
                    "2:21:221": "I got no, no, no",
                    "2:22:770": "I got no, no, no rival",
                    "2:24:149": "No rival",
                    "2:29:116": "No rival",
                    "2:33:194": "I got no, no, no",
                    "2:34:695": "I got no, no, no rival",
                    "2:41:239": "No rival",
                    "2:59:204": "No rival",
                },
            }, {
                name: "Initial D - Don't Stand so Close",
                src: "https://cdn.discordapp.com/attachments/976188754417025144/1074693171419820122/Initial_D_-_Dont_Stand_So_Close_AMV.mp3",
                sync: {
                    "9:629": "We'll be together",
                    "10:847": "'till the morning light",
                    "12:877": "Don't stand so",
                    "14:400": "Don't stand so",
                    "15:928": "Don't stand so close to me",
                    "30:895": "Baby you belong to me",
                    "34:085": "Yes you do, yes you do",
                    "35:377": "You're my affection",
                    "37:118": "I can make a woman cry",
                    "40:129": "Yes I do, yes I do",
                    "41:668": "I will be good",
                    "43:380": "You're like a cruel device",
                    "45:041": "your blood is cold like ice",
                    "46:605": "Posion for my veins",
                    "48:205": "I'm breaking my chains",
                    "49:710": "One look and you can kill",
                    "51:228": "my pain now is your thrill",
                    "52:817": "Your love is for me",
                    "55:108": "I say, Try me",
                    "56:567": "take a chance on emotions",
                    "58:829": "For now and ever",
                    "1:0:19": "close to your heart",
                    "1:1:299": "I say, Try me",
                    "1:2:725": "take a chance on my passion",
                    "1:5:102": "We'll be together all the time",
                    "1:7:383": "I say, Try me",
                    "1:8:874": "take a chance on emotions",
                    "1:11:142": "For now and ever into my heart",
                    "1:13:279": "I say, Try me",
                    "1:14:989": "take a chance on my passion",
                    "1:17:349": "We'll be together",
                    "1:18:429": "'till the morning light",
                    "1:20:610": "Don't stand so",
                    "1:22:210": "Don't stand so",
                    "1:23:639": "Don't stand so close to me",
                    "1:38:607": "Baby let me take control",
                    "1:41:679": "Yes I do, yes I do",
                    "1:43:254": "You are my target",
                    "1:44:897": "No one ever made me cry",
                    "1:47:969": "What you do, what you do",
                    "1:49:406": "Baby's so bad",
                    "1:51:134": "You're like a cruel device",
                    "1:52:521": "your blood is cold like ice",
                    "1:54:293": "Posion for my veins",
                    "1:55:754": "I'm breaking my chains",
                    "1:57:333": "One look and you can kill",
                    "1:58:879": "my pain now is your thrill",
                    "2:0:607": "Your love is for me",
                    "2:2:690": "I say, Try me",
                    "2:4:271": "take a chance on emotions",
                    "2:6:599": "For now and ever",
                    "2:7:824": "close to your heart",
                    "2:8:715": "I say, Try me",
                    "2:10:394": "take a chance on my passion",
                    "2:12:733": "We'll be together all the time",
                    "2:14:993": "I say, Try me",
                    "2:16:298": "take a chance on emotions",
                    "2:18:900": "For now and ever into my heart",
                    "2:21:209": "I say, Try me",
                    "2:22:652": "take a chance on my passion",
                    "2:24:972": "We'll be together",
                    "2:26:129": "'till the morning light",
                    "2:28:216": "Don't stand so",
                    "2:29:856": "Don't stand so",
                    "2:31:296": "Don't stand so close to me",
                    "2:58:89": "I say, Try me",
                    "2:59:679": "take a chance on emotions",
                    "3:1:937": "For now and ever",
                    "3:3:47": "close to your heart",
                    "3:4:231": "I say, Try me",
                    "3:5:820": "take a chance on my passion",
                    "3:8:140": "We'll be together all the time",
                    "3:10:495": "I say, Try me",
                    "3:11:883": "take a chance on emotions",
                    "3:14:267": "For now and ever into my heart",
                    "3:16:558": "I say, Try me",
                    "3:18:67": "take a chance on my passion",
                    "3:20:464": "We'll be together",
                    "3:21:515": "'till the morning light",
                    "3:23:694": "Don't stand so",
                    "3:25:176": "Don't stand so",
                    "3:26:768": "Don't stand so close to me",
                    "3:41:739": "Try me",
                    "3:42:830": "take a chance on emotions",
                    "3:45:0": "For now and ever",
                    "3:46:271": "close to your heart",
                    "3:47:296": "I say, Try me",
                    "3:48:816": "take a chance on my passion",
                    "3:51:163": "We'll be together all the time",
                    "3:53:505": "I say, Try me",
                    "3:55:28": "take a chance on emotions",
                    "3:57:379": "For now and ever into my heart",
                    "3:59:667": "I say, Try me",
                    "4:1:216": "take a chance on my passion",
                    "4:3:507": "We'll be together",
                    "4:4:755": "'till the morning light",
                    "4:6:783": "Don't stand so",
                    "4:8:292": "Don't stand so",
                    "4:9:791": "Don't stand so close to me",
                },
            }, {
                name: "Initial D - The Top",
                src: "https://cdn.discordapp.com/attachments/976188754417025144/1074417409626226728/initial_D_MAD_The_Top_1.mp3",
                sync: {
                    "39:401": "Final lap",
                    "40:516": "I'm on top of the world",
                    "41:618": "And I will never rest",
                    "43:667": "for second again",
                    "45:448": "One more time",
                    "46:410": "I have beaten them out",
                    "47:999": "The scent of gasoline",
                    "49:831": "announces the end",
                    "51:388": "They all said",
                    "52:838": "I'd best give it up",
                    "54:137": "What a fool",
                    "55:40": "to believe their lies",
                    "57:528": "Now they've fall",
                    "58:976": "and I'm at the top",
                    "1:0:116": "Are you ready now to die?",
                    "1:3:151": "I came up from the bottom",
                    "1:4:759": "and into the top",
                    "1:6:170": "For the first time",
                    "1:7:211": "I feel alive",
                    "1:9:373": "I can fly like an eagle",
                    "1:10:574": "strike like a hawk",
                    "1:12:170": "Do you think",
                    "1:12:997": "you can survive the top",
                    "1:15:328": "the top",
                    "1:27:347": "Final turn",
                    "1:28:526": "and I'll settle the score",
                    "1:30:177": "A rubber fire screams",
                    "1:31:392": "into the night",
                    "1:33:483": "Crash and burn is",
                    "1:34:747": "what you're gonna do",
                    "1:36:17": "I am a master",
                    "1:37:77": "of the asphalt fight",
                    "1:39:517": "They all said",
                    "1:40:563": "I'd best give it up",
                    "1:42:134": "What a fool",
                    "1:42:846": "to believe their lies",
                    "1:45:415": "Now they've fall",
                    "1:46:775": "and I'm at the top",
                    "1:48:175": "Are you ready now to die?",
                    "1:51:55": "I came up from the bottom",
                    "1:52:745": "and into the top",
                    "1:54:225": "For the first time",
                    "1:55:9": "I feel alive",
                    "1:57:343": "I can fly like an eagle",
                    "1:58:907": "strike like a hawk",
                    "2:0:153": "Do you think",
                    "2:0:794": "you can survive?",
                    "2:3:120": "I came up from the bottom",
                    "2:4:775": "and into the top",
                    "2:6:92": "For the first time",
                    "2:7:233": "I feel alive",
                    "2:9:212": "I can fly like an eagle",
                    "2:10:951": "strike like a hawk",
                    "2:12:79": "Do you think",
                    "2:12:904": "you can survive the top",
                    "2:27:859": "What were you thinking",
                    "2:28:721": "telling me to change my game?",
                    "2:30:588": "This style wasn't",
                    "2:31:247": "going anywhere",
                    "2:32:216": "it was kaput!",
                    "2:33:227": "You want to see what",
                    "2:33:793": "I've done with this place",
                    "2:35:39": "this whole thing?",
                    "2:36:322": "You want to see that",
                    "2:36:850": "I changed the game?",
                    "2:37:471": "No, I AM the game!",
                    "2:40:117": "Before I knew where",
                    "2:40:698": "this was going",
                    "2:41:320": "I would've listened to you",
                    "2:42:392": "Right now",
                    "2:42:992": "I distance myself from",
                    "2:43:665": "what you have to say!",
                    "2:44:894": "I made this",
                    "2:45:650": "something way bigger",
                    "2:46:403": "than you're ever gonna be",
                    "2:47:926": "I made it this far",
                    "2:49:494": "and I'm taking it to the top",
                    "2:51:115": "I came up from the bottom",
                    "2:52:854": "And into the top",
                    "2:54:185": "For the first time",
                    "2:55:106": "I feel alive!",
                    "2:57:195": "I can fly like an eagle",
                    "2:58:857": "And strike like a hawk",
                    "3:0:30": "Do you think",
                    "3:0:994": "you can survive...",
                    "3:3:53": "I came up from the bottom",
                    "3:4:751": "And into the top",
                    "3:6:141": "For the first time",
                    "3:7:211": "I feel alive!",
                    "3:9:171": "I can fly like an eagle",
                    "3:11:11": "And strike like a hawk",
                    "3:12:91": "Do you think",
                    "3:12:800": "you can survive... the top?",
                    "3:51:44": "I came up from the bottom",
                    "3:52:746": "And into the top",
                    "3:54:26": "For the first time",
                    "3:55:95": "I feel alive!",
                    "3:57:135": "I can fly like an eagle",
                    "3:58:615": "And strike like a hawk",
                    "4:0:153": "Do you think",
                    "4:0:776": "you can survive...",
                    "4:3:102": "I came up from the bottom",
                    "4:4:782": "And into the top",
                    "4:6:32": "For the first time",
                    "4:7:6": "I feel alive!",
                    "4:9:57": "I can fly like an eagle",
                    "4:10:876": "And strike like a hawk",
                    "4:12:188": "Do you think",
                    "4:12:852": "you can survive... the top?",
                },
            }, {
                name: "Initial D - Gas Gas Gas",
                src: "https://cdn.discordapp.com/attachments/976188754417025144/1074417409303269478/Manuel_-_Gas_Gas_Gas_1.mp3",
                sync: {
                    "16:852": "Ah",
                    "20:9": "gas, gas, gas, gas",
                    "23:124": "Ah",
                    "28:271": "Do you like..",
                    "29:853": "my car",
                    "31:468": "m y c a r",
                    "33:132": "m  y  c  a  r",
                    "53:109": "Guess you're ready",
                    "54:291": "'cause I'm waiting for you",
                    "56:129": "It's gonna be so exciting",
                    "59:290": "Got this feeling",
                    "1:0:499": "really deep in my soul",
                    "1:2:281": "Let's get out",
                    "1:3:135": "I wanna go",
                    "1:4:48": "come along",
                    "1:4:855": "get it on",
                    "1:5:993": "Gonna take my car",
                    "1:7:562": "gonna sit in",
                    "1:9:35": "Gonna drive along",
                    "1:10:474": "'til I get you",
                    "1:11:823": "'Cause I'm crazy",
                    "1:12:562": "hot and ready",
                    "1:13:541": "but you like it",
                    "1:15:10": "I wanna race for you",
                    "1:16:610": "(Shall I go now?)",
                    "1:18:109": "Gas, gas, gas",
                    "1:19:810": "I'm gonna step on the gas",
                    "1:21:642": "Tonight, I'll fly",
                    "1:22:962": "(and be your lover)",
                    "1:24:370": "Yeah, yeah, yeah",
                    "1:26:101": "I'll be so quick as a flash",
                    "1:27:884": "And I'll be your hero",
                    "1:30:651": "Gas, gas, gas",
                    "1:32:379": "I'm gonna run as a flash",
                    "1:34:59": "Tonight, I'll fight",
                    "1:35:507": "(to be the winner)",
                    "1:36:707": "Yeah, yeah, yeah",
                    "1:38:547": "I'm gonna step on the gas",
                    "1:40:286": "And you'll see the big show",
                    "1:55:520": "Don't be lazy",
                    "1:56:751": "'cause I'm burning for you",
                    "1:58:340": "It's like a hot sensation",
                    "2:1:733": "Got this power",
                    "2:2:913": "that is taking me out",
                    "2:4:681": "Yes, I've got a crush on you",
                    "2:6:347": "ready, now",
                    "2:7:174": "ready, go",
                    "2:8:335": "Gonna take my car",
                    "2:9:935": "gonna sit in",
                    "2:11:481": "Gonna drive alone",
                    "2:12:775": "'til I get you",
                    "2:14:244": "'Cause I'm crazy",
                    "2:14:975": "hot and ready",
                    "2:15:999": "but you like it",
                    "2:17:279": "I wanna race for you",
                    "2:18:938": "(Shall I go now?)",
                    "2:20:455": "Gas, gas, gas",
                    "2:22:178": "I'm gonna step on the gas",
                    "2:23:999": "Tonight, I'll fly",
                    "2:25:311": "(and be your lover)",
                    "2:26:738": "Yeah, yeah, yeah",
                    "2:28:512": "I'll be so quick as a flash",
                    "2:29:975": "And I'll be your hero",
                    "2:32:978": "Gas, gas, gas",
                    "2:34:668": "I'm gonna run as a flash",
                    "2:36:447": "Tonight, I'll fight",
                    "2:37:809": "(to be the winner)",
                    "2:39:81": "Yeah, yeah, yeah",
                    "2:40:931": "I'm gonna step on the gas",
                    "2:42:463": "And you'll see the big show",
                    "3:10:277": "Guess you're ready",
                    "3:11:426": "'cause I'm waiting for you",
                    "3:13:215": "It's gonna be so exciting",
                    "3:16:471": "Got this feeling",
                    "3:17:789": "really deep in my soul",
                    "3:19:408": "Let's get out",
                    "3:20:224": "I wanna go",
                    "3:21:197": "come along",
                    "3:22:34": "get it on",
                    "3:23:234": "Gonna take my car",
                    "3:25:986": "do you like",
                    "3:27:605": "my car?",
                    "3:29:5": "'Cause I'm crazy",
                    "3:29:685": "hot and ready",
                    "3:30:823": "but you like it",
                    "3:32:133": "I wanna race for you",
                    "3:33:653": "(Shall I go now?)",
                    "3:36:813": "Gas, gas, gas",
                    "3:38:514": "I'm gonna step on the gas",
                    "3:40:185": "Tonight, I'll fly",
                    "3:41:665": "(and be your lover)",
                    "3:43:46": "Yeah, yeah, yeah",
                    "3:44:756": "I'll be so quick as a flash",
                    "3:46:354": "And I'll be your hero",
                    "3:49:245": "Gas, gas, gas",
                    "3:51:130": "I'm gonna run as a flash",
                    "3:52:840": "Tonight, I'll fight",
                    "3:54:90": "(to be the winner)",
                    "3:55:448": "Yeah, yeah, yeah",
                    "3:57:389": "I'm gonna step on the gas",
                    "3:58:866": "And you'll see the big show",
                    "4:1:797": "Gas, gas, gas",
                    "4:4:805": "Yeah, yeah, yeah",
                    "4:7:975": "Gas, gas, gas",
                    "4:11:293": "And you'll see the big show",
                    "4:28:89": "Ah"
                },
            }, {
                name: "Initial D - Running In The 90's",
                src: "https://cdn.discordapp.com/attachments/976188754417025144/1074691658643415050/Running_In_The_90s_2.mp3",
                sync: {
                    "37:412": "Modern talking",
                    "38:991": "modern walking in the streets",
                    "41:601": "New desire",
                    "43:481": "Take me higher",
                    "45:89": "lift me higher with your speed",
                    "47:729": "I need fire",
                    "49:220": "Get the satellite",
                    "50:892": "if you want to see me",
                    "52:225": "Talking on the net",
                    "53:699": "I know the way you like it",
                    "55:329": "Get your credit card",
                    "56:862": "'cause I need no money",
                    "58:339": "All I wanna get is you",
                    "1:0:480": "baby",
                    "1:1:344": "Running in the 90's",
                    "1:3:976": "is a new way I like to be",
                    "1:6:664": "I'm just running in the 90's",
                    "1:10:141": "Come on baby, run to me",
                    "1:12:800": "We are running in the 90's",
                    "1:16:141": "it's a new way to set me free",
                    "1:18:722": "I'm just running in the 90's",
                    "1:22:242": "Yes, I wanna know",
                    "1:23:850": "yes, I wanna see",
                    "1:37:880": "Cyber talking",
                    "1:39:613": "cybersex is on the line",
                    "1:42:184": "New desire",
                    "1:44:150": "Take me higher",
                    "1:45:691": "boost me higher with your mind",
                    "1:48:203": "Set me on fire",
                    "1:49:645": "Get the satellite",
                    "1:51:347": "if you want to see me",
                    "1:52:769": "Talking on the net",
                    "1:54:379": "I know the way you like it",
                    "1:55:896": "Get your credit card",
                    "1:57:307": "'cause I need no money",
                    "1:58:617": "All I wanna get is you",
                    "2:1:97": "baby",
                    "2:1:814": "Running in the 90's",
                    "2:4:582": "is a new way I like to be",
                    "2:7:196": "I'm just running in the 90's",
                    "2:10:595": "Come on baby, run to me",
                    "2:13:233": "We are running in the 90's",
                    "2:16:673": "it's a new way to set me free",
                    "2:19:225": "I'm just running in the 90's",
                    "2:22:868": "Yes, I wanna know",
                    "2:24:325": "yes, I wanna see",
                    "2:42:690": "New desire",
                    "2:48:845": "I need fire",
                    "3:2:496": "Running in the 90's",
                    "3:5:165": "is a new way I like to be",
                    "3:7:744": "I'm just running in the 90's",
                    "3:11:424": "Come on, baby, run to me",
                    "3:13:885": "We are running in the 90's",
                    "3:17:333": "it's a new way to set me free",
                    "3:19:971": "I'm just running in the 90's",
                    "3:23:451": "Yes, I wanna know",
                    "3:24:949": "yes, I wanna see",
                    "3:45:179": "Take me higher",
                    "3:46:699": "lift me higher with your speed",
                    "3:49:356": "I need fire",
                    "3:50:937": "Get the satellite",
                    "3:53:983": "talking on the net",
                    "3:56:922": "Get your credit card",
                    "4:0:4": "all I wanna get",
                    "4:2:899": "Running in the 90's",
                    "4:8:968": "Running in the 90's",
                    "4:15:200": "Running in the 90's",
                    "4:21:190": "Running in the 90's",
                },
            }, {
                name: "Initial D - No One Sleep In Tokyo",
                src: "https://cdn.discordapp.com/attachments/1059159650026659842/1075151008910561330/Initial_D_-_No_One_Sleep_In_Tokyo.mp3",
                sync: {
                    "666": "(4... 3... 2... 1...)",
                    "19:197": "no one sleep in Tokyo",
                    "22:301": "all right crossing the line",
                    "25:392": "no one quit the radio",
                    "28:432": "Tokyo is on fire",
                    "43:821": "even if you say",
                    "45:341": "'I have been the world wide'",
                    "47:124": "I'll take you where",
                    "48:190": "surely you have never been",
                    "50:558": "all right in the fight",
                    "52:47": "I'm OK... come on",
                    "56:5": "come on",
                    "59:374": "hey do you feel",
                    "1:0:688": "the night is breathable",
                    "1:2:760": "look at this town",
                    "1:3:347": "which is unbelievable",
                    "1:4:805": "no other places",
                    "1:6:21": "like that in the world",
                    "1:9:264": "worldddd",
                    "1:10:144": "worlddddddddd (1, 2, 3, 4)",
                    "1:11:825": "no one sleep in Tokyo",
                    "1:14:843": "all right crossing the line",
                    "1:18:137": "no one quit the radio",
                    "1:21:203": "Tokyo is on fire",
                    "1:24:393": "no one sleep in Tokyo",
                    "1:27:302": "all right crossing the line",
                    "1:30:403": "no one quit the radio",
                    "1:33:473": "Tokyo is on fire",
                    "1:48:894": "turning to the left",
                    "1:50:364": "easy chicks and red lights",
                    "1:52:367": "and to the right",
                    "1:53:305": "crazy music everywhere",
                    "1:55:705": "all right in the fight",
                    "1:56:855": "I'm OK... come on",
                    "2:0:924": "come on",
                    "2:4:448": "hey do you feel",
                    "2:5:832": "the night is breathable",
                    "2:7:767": "look at this town",
                    "2:8:514": "which is unbelievable",
                    "2:10:885": "no other places",
                    "2:11:984": "like that in the world",
                    "2:14:333": "worldddd",
                    "2:15:245": "worlddddddddd (1, 2, 3, 4)",
                    "2:16:842": "no one sleep in Tokyo",
                    "2:20:26": "all right crossing the line",
                    "2:23:77": "no one quit the radio",
                    "2:26:286": "Tokyo is on fire",
                    "2:29:266": "no one sleep in Tokyo",
                    "2:32:487": "all right crossing the line",
                    "2:35:436": "no one quit the radio",
                    "2:38:546": "Tokyo is on fire",
                    "3:18:369": "(come on)",
                    "3:32:566": "(1, 2, 3, 4)",
                    "3:37:328": "all right crossing the line",
                    "3:43:658": "Tokyo is on fire",
                    "3:59:82": "hey do you feel",
                    "4:0:318": "the night is breathable",
                    "4:2:486": "look at this town",
                    "4:3:515": "which is unbelievable",
                    "4:5:525": "no other places",
                    "4:6:600": "like that in the world",
                    "4:8:992": "worldddd",
                    "4:9:680": "worlddddddddd (1, 2, 3, 4)",
                    "4:11:454": "no one sleep in Tokyo",
                    "4:14:568": "all right crossing the line",
                    "4:17:616": "no one quit the radio",
                    "4:20:747": "Tokyo is on fire",
                    "4:23:779": "no one sleep in Tokyo",
                    "4:26:950": "all right crossing the line",
                    "4:30:51": "no one quit the radio",
                    "4:33:70": "Tokyo is on fire",
                },
            }];
            let converToJSDelay = (time) => {
                let newTime = time.split(":").reverse();
                time = 0;
                let convert = [6e4 * 60, 6e4, 1000, 1].reverse();
                newTime.forEach((b, c) => {
                    time += b * convert[c];
                });
                return time;
            };
            songs.forEach(e => {
                let oldDatas = e.sync;
                e.sync = {};
                for (let time in oldDatas) {
                    e.sync[converToJSDelay(time)] = oldDatas[time];
                }
            });
            var autoGrindHotkey = {
                toggle: false,
                last: 0,
            };
            var streamModeOpacity = 1;
            document.streamMode = function() {
                //toggleNames = !toggleNames;
                streamModeOpacity = streamModeOpacity ? 0 : 1;
                $("#leaderboard").animate({
                    opacity: streamModeOpacity
                });
                $("#scoreDisplay").animate({
                    opacity: streamModeOpacity
                });
                $("#partyButton").animate({
                    opacity: streamModeOpacity
                });
            };
            document.cleanTextures = function() {
                textures = {};
                texture = {};
                setValue("textures", JSON.stringify({}));
                document.getElementById("textures").options.length = 0;
            }
            document.generateFixedClan = function() {
                setTimeout(() => io.send("8", document.getElementById("fixedClanCreationValue").value), 1 + (player.team ? 750 : 0));
                player.team && io.send("9");
            }
            document.changeMenu = function(e) {
                document.getElementById("mainSettings").style.display = "none";
                document.getElementById("offenseSettings").style.display = "none";
                document.getElementById("supportSettings").style.display = "none";
                document.getElementById("defenseSettings").style.display = "none";
                document.getElementById("chatSettings").style.display = "none";
                document.getElementById("hotkeySettings").style.display = "none";
                switch (e) {
                    case 0:
                        document.getElementById("mainSettings").style.display = "block";
                        break
                    case 1:
                        document.getElementById("offenseSettings").style.display = "block";
                        break
                    case 2:
                        document.getElementById("supportSettings").style.display = "block";
                        break
                    case 3:
                        document.getElementById("defenseSettings").style.display = "block";
                        break
                    case 4:
                        document.getElementById("chatSettings").style.display = "block";
                        break
                    case 5:
                        document.getElementById("hotkeySettings").style.display = "block";
                        break
                }
            }
            $("head").append(`
            <style>
@keyframes rainbow {
    0%{background-position:0% 50%}
    50%{background-position:100% 25%}
    100%{background-position:0% 50%}
}
</style>
            `);
            $("body").append(`
           <div id="modMenus" style="display: block;
           padding: 10px;
           border-radius: 15px;
           background-color: rgba(0, 0, 0, 0.25);
           border-radius: 3px;
           position: absolute;
           left: 20px;
           top: 20px;
           width: 375px;">
           </div>`);
            $("#mainMenu").css({
                "overflow-y": "scroll"
            });
            $("#modMenus").append(`<script>
           function toggleUI() {
           document.getElementById(\'gameUI\').style.display = document.getElementById('gameUI').style.display == "block" ? "none" : "block";
           };
           function toggle2() {
           $("#WSSender").toggle();
           };
           </script>
           <div id="helpText"> <legend
           style = "font-size: 30px;background-image: repeating-linear-gradient(45deg, black, indigo, blue, black, green, yellow, black, orange, red, black);background-size: 800% 800%;-webkit-background-clip: text;-webkit-text-fill-color: transparent;animation: rainbow 8s ease infinite;"
           >Black Rainbow:</legend>
           <div style="color: rgb(255, 255, 255);font-size: 12px; overflow-y: scroll; max-height: 150px;">
           <button
           style= "pointer-events:auto; background-color: black; color: white; border-color: white; border-radius: 4px; -moz-border-radius: 4px; -webkit-border-radius: 4px;"
           onclick="document.changeMenu(0)">
           Main
           </button>
           <button
           style= "pointer-events:auto; background-color: black; color: white; border-color: white; border-radius: 4px; -moz-border-radius: 4px; -webkit-border-radius: 4px;"
           onclick="document.changeMenu(1)">Offense</button>
           <button
           style= "pointer-events:auto; background-color: black; color: white; border-color: white; border-radius: 4px; -moz-border-radius: 4px; -webkit-border-radius: 4px;"
           onclick="document.changeMenu(2)">Support</button>
           <button
           style= "pointer-events:auto; background-color: black; color: white; border-color: white; border-radius: 4px; -moz-border-radius: 4px; -webkit-border-radius: 4px;"
           onclick="document.changeMenu(3)">Defense</button>
           <button
           style= "pointer-events:auto; background-color: black; color: white; border-color: white; border-radius: 4px; -moz-border-radius: 4px; -webkit-border-radius: 4px;"
           onclick="document.changeMenu(4)">Chat</button>
           <button
           style= "pointer-events:auto; background-color: black; color: white; border-color: white; border-radius: 4px; -moz-border-radius: 4px; -webkit-border-radius: 4px;"
           onclick="document.changeMenu(5)">Hotkey</button><br><br>
           <div id = "mainSettings">
           <button onclick="document.cleanTextures()">Clean Textures</button><br>
           <button onclick="document.streamMode()">Stream Mode</button><br>
           <button onclick="toggleUI()">UI</button><br><br>
           Create Clan: <input type="text" id="fixedClanCreationValue" placeholder="clan"><button onclick="document.generateFixedClan();">Create Clan</button><br><br>
           </div>
           <div id = "offenseSettings" style="display: none;">
           </div>
           <div id = "supportSettings" style="display: none;">
           </div>
           <div id = "defenseSettings" style="display: none;">
           </div>
           <div id = "chatSettings" style="display: none;">
           </div>
           <div id = "hotkeySettings" style="display: none;">
           </div>
           </div>`);
            CanvasRenderingContext2D.prototype._drawImage = CanvasRenderingContext2D.prototype.drawImage;
            CanvasRenderingContext2D.prototype.drawImage = function(...args) {
                let src = args[0]?.currentSrc;
                if (src) {
                    for (let id in texture) {
                        if(id == undefined) continue;
                        let replaced = new Image();
                        replaced.src = texture[id];
                        if (src.match(id)) {
                            args[0] = replaced;
                            break;
                        }

                    }
                }
                this._drawImage(...args);
            }
            for (let id in settings) {
                if (modules[id] == undefined) {
                    delete settings[id];
                } else switch (modules[id].type) {
                    case "checkbox":
                        if (typeof settings[id] != "boolean") {
                            settings[id] = true;
                        }
                        break;

                }

            }
            settings.textures = textures;
            let texture;
            let timeouts = [];
            for (let id in modules) {
                let module = modules[id];
                if (settings[id] == undefined) {
                    settings[id] = module.default;
                }
                id == "songChats" && (settings.songChats = songs[0].name);
                setValue("settings", JSON.stringify(settings));
                document[id + "OnChange"] = function() {
                    if (module.type == "file") {
                        let file = document.getElementById(id).files[0];
                        var readFile = new FileReader();
                        readFile.readAsText(file);
                        readFile.onload = function() {
                            data = {
                                name: file.name,
                                datas: {},
                            };
                            let texts = readFile.result.split("\n");
                            if (id == "loadTexture") {
                                for (let text of texts) {
                                    let [src, src_2, newSrc] = text.split(", ");
                                    data.datas[src + "_" + src_2] = newSrc;
                                    let option = document.createElement("option");
                                    option.text = data.name;
                                    option.value = data.name;
                                    !textures[data.name] && (texture = data.datas, textures[data.name] = data.datas, document.getElementById("textures").add(option));
                                    setValue("textures", JSON.stringify(textures));
                                }
                            }
                        }
                    } else {
                        settings[id] = document.getElementById(id)[module.type == "checkbox" ? "checked" : "value"];
                        if (id == "songChats") {
                            timeouts.forEach(e => clearTimeout(e));
                            timeouts = [];
                            let song = songs.find(e => e.name == settings.songChats);
                            singing.audio && singing.audio.pause();
                            singing.audio = new Audio(song.src);
                            singing.name = settings.songChats;
                            if (singing.toggle && singing.audio) {
                                singing.audio.onended = function() {
                                    singing.toggle = false;
                                    singing.audio.currentTime = 0;
                                    singing.audio.pause()
                                };
                                singing.audio.play();
                                for (let time in song.sync) {
                                    let message = song.sync[time];
                                    timeouts.push(setTimeout(() => {
                                        chat(message ?? "");
                                    }, time));
                                }
                            }
                        } else if(id == "textures"){
                            console.log("ez");
                        }
                    }
                    setValue("settings", JSON.stringify(settings));
                }
                let newSetting = module.type == "option" ? document.createElement("select") : document.createElement("input");
                module.type != "option" && (newSetting.type = module.type);
                module.type == "checkbox" ? (settings[id] && newSetting.setAttribute("checked", ""), newSetting.setAttribute("onclick",
                                                                                                                             "document[id+'OnChange']()")) : (module.type == "text" && (newSetting.setAttribute("value", settings[id])), newSetting.setAttribute("on" + (module.type == "file" ? "change" : "input"),
            "document[id+'OnChange']()"));
                newSetting.id = id;
                let settingName = document.createElement("label");
                settingName.innerHTML = module.name;
                settingName.setAttribute("for", id);
                document.getElementById(module.category + "Settings").append(settingName);
                document.getElementById(module.category + "Settings").append(newSetting);
                document.getElementById(module.category + "Settings").innerHTML += `<br>`;
                if (module.type == "option") {
                    if (module.options?.length) {
                        for (let data of module.options) {
                            let option = document.createElement("option");
                            option.text = data.id;
                            option.value = data.id;
                            data.id == settings[id] && option.setAttribute("selected", true);
                            document.getElementById(id).add(option);
                        }
                    } else if (id == "songChats") {
                        for (let data of songs) {
                            let option = document.createElement("option");
                            option.text = data.name;
                            option.value = data.name;
                            document.getElementById("songChats").add(option);
                        }
                    } else if (id == "textures") {
                        for (let name in textures) {
                            let option = document.createElement("option");
                            option.text = name;
                            option.value = name;
                            document.getElementById("textures").add(option);
                            !texture && (texture = textures[name]);
                        }
                    }
                }
            }
            $("#modMenu").show();
            var screen = {
                width: 1920,
                height: 1080,
            };
            screen.width = gameCanvas.width;
            screen.height = gameCanvas.height;
            $(window).resize(function() {
                screen.width = gameCanvas.width;
                screen.height = gameCanvas.height;
            });
            var mouse = {
                x: 0,
                y: 0,
                which: null,
            };
            gameCanvas.addEventListener("mousedown", event => {
                mouse.which = event.button;
            });
            gameCanvas.addEventListener("mouseup", event => {
                mouse.which = null;
            });
            gameCanvas.addEventListener("mousemove", event => {
                mouse.x = event.clientX;
                mouse.y = event.clientY;
            });

            function mouseAngle() {
                return UTILS.getDirection(mouse.x, mouse.y, screen.width / 2, screen.height / 2);
            }
            var macro = {
                placer: {
                    i: null,
                    t: false,
                },
            };
            var autoMill = {
                toggle: false,
                x: 0,
                y: 0,
            };
            var instakill = {
                toggle: false,
                toDo: [],
                try: function(other, damage) {
                    if (instakill.toDo.length) return;
                    if (!other || !other.visible) return;
                    let aik = settings.autoInstakill;
                    if (aik && settings.blockAutoInstakillWhileClicking && mouse.which != null) return;
                    let ham = player.weapons[1] == 10;
                    let pro = player.weapons[1] && items.weapons[player.weapons[1]]?.projectile != undefined;
                    let proRang = pro ? items.projectiles[items.weapons[player.weapons[1]].projectile].range : 90000;
                    let proDmg = pro ? items.projectiles[items.weapons[player.weapons[1]].projectile].dmg : 0;
                    let noEmpGuy = enemies.find(e => e.skinIndex != 22);
                    let tur = player.canShot(other, 1) && other == noEmpGuy;
                    let turDmg = tur ? 25 * (other.skin?.dmgMult || 1) : 0;
                    let health = other.health - (damage ?? 0);
                    let stop = function() {
                        choose(player.weapons[0], true);
                        autoHit(false);
                    };
                    let checkCondition = function(weapon, ...indxs) {
                        let dist = UTILS.getDistance(other.x2, other.y2, player.x2, player.y2);
                        if (aik) {
                            return dist <= Math.min(ham ? 75 : pro ? proRang : 9999, items.weapons[player.weapons[0]].range) +
                                63 && indxs.every(indx => {
                                if (!player.canShot(other, indx)) return false;
                                return true;
                            });
                        } else return true;
                    };
                    if (player.weapons[0]) {
                        if (player.reloads[player.weapons[0]]) return;
                        if (ham && checkCondition(player.weapons[1], 1)) {
                            if (player.reloads[player.weapons[1]]) return;
                            let hat = skinConditions(other.skinIndex == 11 ? 22 : 7, 6, 0);
                            let remBull = player.variants[player.weapons[0]].id > 0;
                            let accessory = tailConditions(player.health < 100 ? 18 : 21, 18, 16, 19, 13, 0);
                            let priDamage = items.weapons[player.weapons[0]].dmg * player.variants[player.weapons[0]].val * (store
                                                                                                                             .hats.find(e => e.id == hat)?.dmgMultO || 1) * (other.skin?.dmgMult || 1);
                            let secDamage = 10 * player.variants[10].val * (other.skin?.dmgMult || 1);
                            if (priDamage + secDamage * 1.5 + turDmg < health) return false;
                            let dir = UTILS.getDirection(other.x2, other.y2, player.x2, player.y2);
                            instakill.toDo = [function() {
                                equips(hat, 21);
                                choose(player.weapons[0], true);
                                watch(dir);
                            }, function() {
                                watch(dir);
                                equips(remBull ? 53 : hat, 21);
                                choose(player.weapons[1], true);
                                autoHit(true);
                            }];
                            let add = [];
                            if (remBull) {
                                add = [stop];
                            } else {
                                add = [stop, function() {
                                    equips(53, 21);
                                }];
                            }
                            instakill.toDo.unshift(...add);
                        } else if (pro && checkCondition(player.weapons[0], items.weapons[player.weapons[1]].projectile)) {
                            if (player.reloads[player.weapons[1]]) return;
                            let hat = skinConditions(other.skinIndex == 11 ? 22 : 7, 6, 0);
                            let accessory = tailConditions(player.health < 100 ? 18 : 21, 18, 16, 19, 13, 0);
                            let priDamage = items.weapons[player.weapons[0]].dmg * player.variants[player.weapons[0]].val * (store
                                                                                                                             .hats.find(e => e.id == hat)?.dmgMultO || 1) * (other.skin?.dmgMult || 1);
                            let secDamage = proDmg * (other.skin?.dmgMult || 1);
                            if (priDamage + secDamage + turDmg < health) return false;
                            let dir = UTILS.getDirection(other.x2, other.y2, player.x2, player.y2);
                            instakill.toDo = [stop, function() {
                                equips(priDamage + secDamage >= health ? 6 : 53, 21);
                                choose(player.weapons[1], true);
                                io.send("2", dir);
                            }, function() {
                                watch(dir);
                                equips(hat, 21);
                                choose(player.weapons[0], true);
                                autoHit(true);
                            }];
                            let add = [];
                            instakill.toDo.unshift(...add);
                        } else if (!player.shootCount && checkCondition(player.weapons[0], 1)) { }
                    }
                },
            };
            var autoKillerHit = {
                toDo: [],
                try: function(other, damage) {
                    if (!settings.autoKillerHit) return;
                    if (autoKillerHit.toDo.length) return;
                    if (!other || !other.visible) return;
                    let ham = player.weapons[1] == 10;
                    let noEmpGuy = enemies.find(e => e.skinIndex != 22);
                    let tur = player.canShot(other, 1) && other == noEmpGuy;
                    let turDmg = tur ? 25 * (other.skin?.dmgMult || 1) : 0;
                    let health = other.health - (damage ?? 0);
                    let dist = UTILS.getDistance(other.x2, other.y2, player.x2, player.y2);
                    let stop = function() {
                        choose(player.weapons[0], true);
                        autoHit(false);
                    };
                    let hat = skinConditions(other.skinIndex == 11 ? 22 : 7, 6, 0);
                    let remBull = player.variants[player.weapons[0]].id > 0;
                    let accessory = tailConditions(player.health < 100 ? 18 : 21, 18, 16, 19, 13, 0);
                    let priDamage = items.weapons[player.weapons[0]].dmg * player.variants[player.weapons[0]].val * (store.hats
                                                                                                                     .find(e => e.id == hat)?.dmgMultO || 1) * (other.skin?.dmgMult || 1);
                    let secDamage = 10 * player.variants[10].val * (other.skin?.dmgMult || 1);
                    if (!player.reloads[10] && ham && dist <= 133 && health <= secDamage + turDmg) {
                        let dir = UTILS.getDirection(other.x2, other.y2, player.x2, player.y2);
                        autoKillerHit.toDo = [function() {
                            watch(dir);
                            equips(hat, 21);
                            choose(player.weapons[1], true);
                            autoHit(true);
                        },];
                        let add = [];
                        if (health <= secDamage) {
                            add = [stop];
                        } else {
                            add = [stop, function() {
                                equips(53, 21);
                            }];
                        }
                        autoKillerHit.toDo.unshift(...add);
                    } else if (!player.reloads[player.weapons[0]] && health <= priDamage + turDmg && dist <= items.weapons[player.weapons[0]].range + 63) {
                        let dir = UTILS.getDirection(other.x2, other.y2, player.x2, player.y2);
                        autoKillerHit.toDo = [function() {
                            watch(dir);
                            equips(hat, 21);
                            choose(player.weapons[0], true);
                            autoHit(true);
                        },];
                        let add = [];
                        if (health <= priDamage) {
                            add = [stop];
                        } else {
                            add = [stop, function() {
                                equips(53, 21);
                            }];
                        }
                        autoKillerHit.toDo.unshift(...add);
                    } else if ([player.weapons[0], 10].every(indx => {
                        if (player.reloads[indx]) return false;
                        return true;
                    }) && ham && dist <= 133 && health <= priDamage + secDamage + turDmg) {
                        let dir = UTILS.getDirection(other.x2, other.y2, player.x2, player.y2);
                        autoKillerHit.toDo = [function() {
                            choose(player.weapons[0], true);
                            watch(dir);
                        }, function() {
                            watch(dir);
                            equips(hat, 21);
                            choose(player.weapons[1], true);
                            autoHit(true);
                        },];
                        let add = [];
                        if (health <= priDamage + secDamage) {
                            add = [stop];
                        } else {
                            add = [stop, function() {
                                equips(53, 21);
                            }];
                        }
                        autoKillerHit.toDo.unshift(...add);
                    }
                },
            };
            var autoKillerShot = {
                toDo: [],
                try: function(other, damage) {
                    if (!settings.autoKillerShot) return;
                    if (autoKillerShot.toDo.length) return;
                    if (!other || !other.visible) return;
                    if (!player.weapons[1] || items.weapons[player.weapons[1]].projectile == undefined || player.reloads[player.weapons[1]]) return;
                    let noEmpGuy = enemies.find(e => e.skinIndex != 22);
                    let tur = player.canShot(other, 1) && other == noEmpGuy;
                    let turDmg = tur ? 25 * (other.skin?.dmgMult || 1) : 0;
                    let proDmg = items.projectiles[items.weapons[player.weapons[1]].projectile].dmg * (other.skin?.dmgMult || 1);
                    let health = other.health - (damage ?? 0);
                    let stop = function() {
                        choose(player.weapons[0], true);
                        autoHit(false);
                    };
                    if (proDmg + turDmg < health) return;
                    let dir = UTILS.getDirection(other.x2, other.y2, player.x2, player.y2);
                    autoKillerShot.toDo = [function() {
                        watch(dir);
                        choose(player.weapons[1], true);
                        autoHit(true);
                    },];
                    let add = [];
                    if (health <= proDmg) {
                        add = [stop];
                    } else {
                        add = [stop, function() {
                            equips(53, 21);
                        }];
                    }
                    autoKillerShot.toDo.unshift(...add);

                },
            };
            var autoKillerSpike = {
                try: function(other, damage) {
                    if (!settings.autoKillerSpike) return;
                    if (!other || !other.visible) return;
                    let health = other.health - (damage ?? 0);
                    let dir = UTILS.getDirection(other.x2, other.y2, player.x2, player.y2);
                    let angles = new Array(Math.ceil((35 + items.list[player.items[2]].scale) / 20)).map((a, b) => a + b * 20);
                    let negativeAngles = angles.map(a => a + -1);
                    let allAngles = [...angles, ...negativeAngles];
                    let pos;
                    let placedAngle;
                    if ((placedAngle = allAngles.find(angle => health <= items.list[player.items[2]].dmg && UTILS.getDirection(other
                                                                                                                               .x2, other.y2, (pos = player.buildPosition(items.list[player.items[2]], angle)).x2, pos.y2) <=
                                                      items.list[player.items[2]].scale + 35 && player.buildItem(items.list[player.items[2]], angle)))) {
                        place(player.items[2], placedAngle);
                    }
                },
            };
            var autoPlacer = {
                last: 0,
            };
            var risklyAreas = [];
            var leaderboardPlayers = [];
            var teammates = [];
            var enemies = [];
            var autos = [autoKillerHit, autoKillerShot, instakill];
            var anythingWorks = function() {
                let anyAutoWorking = autos.find(e => e.toDo.length);
                return anyAutoWorking || auto.equiper.allowCount || auto.watcher.allowCount;
            };
            var tickCount = 0;
            var lastShameReset = 0;
            var oldChatText = "";
            var chat = function(text) {
                if (!player.alive) return;
                if (oldChatText == text) return false;
                io.send("ch", text);
                setTimeout(() => {
                    oldChatText = "";
                }, 3e3);
                return true;
            };
            var oldMoveAngle = null;
            var move = function(angle) {
                if (!player.alive) return;
                if (oldMoveAngle == angle) return true;
                io.send("33", angle);
                return true;
            };
            var buy = function(index, isTail) {
                if (!player.alive) return;
                if (myPlayer[(isTail ? "tails" : "skins")][index]) return true;
                let obj = store[(isTail ? "accessories" : "hats")].find(e => e.id == index);
                if (obj && player.points < obj.price) return false;
                if (myPlayer.lastTry.buy[(isTail ? "tail" : "skin") + "Index"] == index) return true;
                io.send("13c", 1, index, isTail);
                return true;
            };
            var buys = function(skin, tail) {
                if (!player.alive) return;
                buy(skin);
                buy(tail, 1);
            };
            var equip = function(index, isTail) {
                if (!player.alive) return;
                if (!myPlayer[(isTail ? "tails" : "skins")][index] && myPlayer.lastTry.equip[(isTail ? "tail" : "skin") + "Index"] != 0)
                    return io.send("13c", 0, 0, isTail);
                if (myPlayer.lastTry.equip[(isTail ? "tail" : "skin") + "Index"] == index) return true;
                io.send("13c", 0, index, isTail);
                return true;
            };
            var equips = function(skin, tail) {
                if (!player.alive) return;
                buy(skin);
                equip(skin);
                equip(buy(tail, 1) ? tail : 0, 1);
            };
            var oldWatchAngle = 0;
            var watch = function(direction) {
                if (!player.alive) return;
                if (UTILS.getAngleDist(oldWatchAngle, direction) < UTILS.toRad(35)) return;
                io.send("2", direction);
            };
            var oldBuild = -1;
            var oldWeapon = 0;
            var choose = function(index, isWpn) {
                if (!player.alive) return;
                if (!player[isWpn ? "weapons" : "items"].includes(index)) return;
                if (isWpn) {
                    if (oldBuild == -1 && oldWeapon == index) return;
                    io.send("5", index, true);
                } else {
                    if (oldBuild == index) return;
                    io.send("5", index);
                }
            };
            var place = function(item, angle = mouseAngle()) {
                if (!player.alive) return;
                if (!player.items.includes(item)) return;
                if (player.buildItem(items.list[item], angle)) {
                    choose(item);
                    io.send("c", 1, angle);
                    choose(oldWeapon, true);
                    anythingWorks() || settings.autoTrapBreaker && player.lockMove && gameObjects.find(e => e.active && e.trap && e.owner.sid != player.sid && !alliancePlayers.includes(e.owner
            .sid) && UTILS.getDistance(e.x, e.y, player.x2, player.y2) <= 50) || mouse.which == 2 && watch(player.d2);
                    if(item >= 6 && item <= 9){
                        for (let tmpObj of enemies.filter(e => UTILS.getDistance(e.x2, e.y2, ...Object.values(player.buildPosition(items.list[player.items[2]], angle))) <= 35 + items.list[player.items[2]].scale)) {
                            autoKillerHit.try(tmpObj, items.list[player.items[2]].dmg);
                        }
                    }
                    return true;
                }
            };
            var hit = function() { };
            var autoHitToggle = 0;
            var autoHit = function(toggle) {
                if (toggle) {
                    autoHitToggle == 0 && io.send("7", 1);
                    autoHitToggle++;
                } else {
                    autoHitToggle == 1 && io.send("7", 1);
                    autoHitToggle--;
                }
            };
            var skinConditions = function() {
                for (let skin of arguments) {
                    if (player.skins[skin] || store.hats.find(e => e.id == skin)?.price <= player.points) return skin;
                }
            }
            var tailConditions = function() {
                for (let tail of arguments) {
                    if (player.tails[tail] || store.accessories.find(e => e.id == tail)?.price <= player.points) return tail;
                }
            }
            let buttonReLeft = 0;
            function keysActive() {
                return (allianceMenu.style.display != "block"
                        && chatHolder.style.display != "block");
            }
            document.addEventListener("keydown", event => {
                let key = event.key.toLowerCase();
                if (key == "escape") {
                    buttonReLeft = !buttonReLeft;
                    $("#topInfoHolder").toggle();
                    $("#modMenus").toggle();
                    $("#allianceButton").css("left", buttonReLeft ? "270px" : "425px");
                    $("#storeButton").css("left", buttonReLeft ? "270px" : "425px");
                }
                if (keysActive()) {
                    let togglePlacer = function(i) {
                        macro.placer.t = true;
                        macro.placer.i = i;
                    }
                    switch (key) {
                        case settings.autoGrindHotkey:
                            autoGrindHotkey.toggle = !autoGrindHotkey.toggle;
                            autoHit(autoGrindHotkey.toggle);
                            break
                        case settings.instakillHotkey:
                            instakill.toggle = !instakill.toggle;
                            break
                        case settings.autoMillHotkey:
                            autoMill.toggle = !autoMill.toggle;
                            break
                        case settings.healHotkey:
                            key == "q" && io.send("5", oldWeapon, true);
                            togglePlacer(0);
                            break
                        case settings.spikeHotkey:
                            togglePlacer(2);
                            break
                        case settings.trapHotkey:
                            togglePlacer(4);
                            break
                        case settings.turretHotkey:
                            togglePlacer(5);
                            break
                        case "c":
                            (() => {
                                singing.toggle = !singing.toggle;
                                timeouts.forEach(e => clearTimeout(e));
                                timeouts = [];
                                let song = songs.find(e => e.name == settings.songChats);
                                singing.name = settings.songChats;
                                if (singing.toggle && singing.audio) {
                                    singing.audio.onended = function() {
                                        singing.toggle = false;
                                        singing.audio.currentTime = 0;
                                        singing.audio.pause()
                                    };
                                    singing.audio.play();
                                    for (let time in song.sync) {
                                        let message = song.sync[time];
                                        timeouts.push(setTimeout(() => {
                                            chat(message ?? "");
                                        }, time));
                                    }
                                } else {
                                    singing.audio && (singing.audio.currentTime = 0, singing.audio.pause());
                                }
                            })();
                            break
                    }
                }
            });
            document.addEventListener("keyup", event => {
                let key = event.key.toLowerCase();
                if ([settings.healHotkey, settings.spikeHotkey, settings.trapHotkey, settings.turretHotkey].includes(key)) {
                    macro.placer.t = false;
                }
            });
            var commands = {
                p: "!",
                u: {
                    changePrefix: function(prefix) {
                        this.prefix = prefix;
                    },
                    sync: function() { },
                },
                t: {
                    sync: function() { },
                },
            };

            var myPlayer = {
                lastTry: {
                    equip: {
                        skin_index: 0,
                        tail_index: 0,
                    },
                    buy: {
                        skin_index: 0,
                        tail_index: 0,
                    },
                    choose: [-1, null],
                },
                skins: [],
                tails: [],
            };
            var enemy = {};
            var teammate = {};
            var getPlayer = function(sid) {
                return players.find(e => e.sid == sid);
            };
            var getObject = function(sid) {
                return gameObjects.find(e => e.sid == sid);
            };
            var getAI = function(sid) {
                return ais.find(e => e.sid == sid);
            };
            var getProjectile = function(sid) {
                return projectiles.find(e => e.sid == sid);
            };
            var autoImg = {
                inRisk: {
                    image: "https://icones.pro/wp-content/uploads/2021/08/symbole-cible-rouge.png",
                    target: null,
                },
                instaable: {
                    image: "https://icones.pro/wp-content/uploads/2021/08/symbole-cible-noir.png",
                    target: null,
                },
            };
            var manualImg = {
                enemyRadar: {
                    image: "https://www.onlygfx.com/wp-content/uploads/2018/04/grunge-triangle-1-1024x940.png",
                }
            };
            [autoImg, manualImg].forEach(each => {
                Object.values(each).forEach(_each => {
                    let image = document.createElement("img");
                    image.src = _each.image;
                    image.loaded = false;
                    image.onload = function() {
                        image.loaded = true;
                    }
                    _each.image = image;
                })
            });
            var smtWorking = false;
            var auto = {
                watcher: {
                    allowCount: 0,
                    start: function() {
                        this.allowCount++;
                    },
                    stop: function() {
                        this.allowCount = Math.max(0, this.allowCount - 1);
                    },
                },
                equiper: {
                    allowCount: 0,
                    start: function() {
                        this.allowCount++;
                    },
                    stop: function() {
                        this.allowCount = Math.max(0, this.allowCount - 1);
                    },
                },
            };
            var handleMessage = {
                manage: function(x) {
                    let [packet, data] = msgpack.decode(new Uint8Array(x));
                    handleMessage[packet](...data);
                },
                "2": function(direction) {
                    oldWatchAngle = direction;
                },
                "33": function(direction) {
                    oldMoveAngle = direction;
                },
                "5": function(index, isWpn) {
                    isWpn ? (oldBuild = -1, oldWeapon = index) : oldBuild = index;
                },
                "6": function() { },
                "7": function() { },
                "8": function() { },
                "9": function() {
                    alliancePlayers = [];
                },
                "10": function() { },
                "11": function() { },
                "12": function() { },
                "13c": function(isBuy, index, isTail) {
                    if (isBuy) {
                        myPlayer.lastTry.buy[(isTail ? "tail" : "skin") + "_index"] = index;
                        myPlayer[isTail ? "tails" : "skins"][index] = true;
                    } else {
                        myPlayer.lastTry.equip[(isTail ? "tail" : "skin") + "_index"] = index;
                    }
                },
                "14": function() { },
                "sp": function() { },
                "pp": function() { },
                "c": function(hit, direction) {
                    direction != null && hit && (oldWatchAngle = direction);
                },
                "rmd": function() { },
                "ch": function(message, isMirror) {
                    oldChatText = message;
                    if (isMirror || !message.length) return;
                    let splittedMessage = message.split(commands.p);
                    if (splittedMessage.length < 2) return;
                    splittedMessage = splittedMessage[1].split(" -");
                    let command = splittedMessage[0],
                        values = [];
                    if (splittedMessage.length > 1) {
                        values = splittedMessage.slice(1, splittedMessage.length);
                    }
                    commands.u[command] && commands.u[command](...values);
                }
            };
            WebSocket.prototype._send = WebSocket.prototype.send;
            WebSocket.prototype.send = function(datas) {
                if (!connected) {
                    connected = true;
                    connectSocket(this);
                    setTimeout(() => settings.autoSpawn && io.send("sp", {
                        name: nameInput.value,
                        moofoll: 1,
                        skin: 6,
                    }), 200);
                }
                this.send = function(datas) {
                    let [packet, data, isMods] = msgpack.decode(new Uint8Array(datas));
                    if (["2", "c"].includes(packet) && !isMods) return;
                    handleMessage.manage(datas);
                    antiCheatCalculator.sentToServer();
                    this._send(datas);
                };
                this.send(datas);
            };

            function io_init() { }

            function setInitData(datas) {
                alliances = datas.teams;
            }

            function disconnect(reason) {
                console.log("web socket closed because of " + reason);
            }

            function setupGame(sid) {
                playerSID = sid;
            }

            function addPlayer(datas, isYou) {
                var tmpPlayer = players.find(e => e.id == datas[0]);
                if (!tmpPlayer) {
                    tmpPlayer = new Player(datas[0], datas[1], config, UTILS, projectileManager,
                                           objectManager, players, ais, items, ...Object.values(store));
                    players.push(tmpPlayer);
                }
                tmpPlayer.spawn(isYou ? 1 : null);
                tmpPlayer.visible = false;
                tmpPlayer.x2 = undefined;
                tmpPlayer.y2 = undefined;
                tmpPlayer.setData(datas);
                if (isYou) {
                    player = tmpPlayer;
                    camX = player.x;
                    camY = player.y;
                }
            }

            function removePlayer(id) {
                for (var i = 0; i < players.length; i++) {
                    if (players[i].id == id) {
                        players.splice(i, 1);
                        break;
                    }
                }
            }

            function upgradeDatas(tmpObj) {
                if (tmpObj != player) {
                    let dists = [UTILS.getDistance(player.x2, player.y2, tmpObj.x2, tmpObj.y2), UTILS.getDistance(player.x2, player.y2,
                                                                                                                  enemies[0]?.x2, enemies[0]?.y2)];
                    if (tmpObj.team && tmpObj.team == player.team) {
                        dists = [UTILS.getDistance(player.x2, player.y2, tmpObj.x2, tmpObj.y2), UTILS.getDistance(player.x2, player.y2,
                                                                                                                  teammates[0]?.x2, teammates[0]?.y2)];
                        if (teammates.length && dists[0] < dists[1]) teammates.unshift(tmpObj);
                        else teammates.push(tmpObj);
                    } else if (enemies.length && dists[0] < dists[1]) enemies.unshift(tmpObj);
                    else enemies.push(tmpObj);
                }
            }

            function updatePlayers(datas) {
                tickCount++;
                var tmpTime = Date.now();
                for (let tmpObj of players) {
                    tmpObj.forcePos = !tmpObj.visible;
                    tmpObj.visible = false;
                }
                teammates = [];
                enemies = [];
                for (let i = 0; i < datas.length;) {
                    let data = datas.slice(i, i + 13);
                    let tmpObj = getPlayer(data[0]);
                    if (tmpObj) {
                        tmpObj.t1 = (tmpObj.t2 === undefined) ? tmpTime : tmpObj.t2;
                        tmpObj.t2 = tmpTime;
                        tmpObj.x1 = tmpObj.x;
                        tmpObj.y1 = tmpObj.y;
                        tmpObj.x3 = tmpObj.x2;
                        tmpObj.y3 = tmpObj.y2;
                        tmpObj.x2 = data[1];
                        tmpObj.y2 = data[2];
                        tmpObj.d1 = (tmpObj.d2 === undefined) ? data[3] : tmpObj.d2;
                        tmpObj.d2 = data[3];
                        tmpObj.dt = 0;
                        tmpObj.buildIndex = data[4];
                        tmpObj.weaponIndex = data[5];
                        tmpObj.weaponVariant = data[6];
                        tmpObj.team = data[7];
                        tmpObj.isLeader = data[8];
                        tmpObj.skinIndex = data[9];
                        tmpObj.tailIndex = data[10];
                        tmpObj.iconIndex = data[11];
                        tmpObj.zIndex = data[12];
                        tmpObj.visible = true;
                        tmpObj.update(1e3 / 9);
                        upgradeDatas(tmpObj);
                        i += 13;
                    }
                }
                enemy = enemies[0];
                teammate = teammates[0];
                pushToTick.forEach(e => e.action(...e.datas));
                pushToTick = [];
                runScript();
            }

            function runScript() {
                objectManager.getObjects(0, 0, config.mapScale).forEach(e => {
                    e.shootCount = Math.max(0, e.shootCount - 1e3 / 9);
                });
                if (!player.team) alliancePlayers = [];
                macro.placer.t && place(player.items[macro.placer.i]);
                let trap = gameObjects.find(e => e.active && e.trap && e.owner.sid != player.sid && !alliancePlayers.includes(e.owner
                                                                                                                              .sid) && UTILS.getDistance(e.x, e.y, player.x2, player.y2) <= 50);
                let autoTrapBreaker = settings.autoTrapBreaker && player.lockMove && trap;
                if (autoMill.toggle) {
                    if (UTILS.getDistance(player.x2, player.y2, autoMill.x, autoMill.y) > items.list[player.items[3]].scale * 2) {
                        let tmpDir = UTILS.getDirection(player.x3, player.y3, player.x2, player.y2);
                        place(player.items[3], tmpDir - UTILS.toRad(72));
                        place(player.items[3], tmpDir);
                        place(player.items[3], tmpDir + UTILS.toRad(72));
                        autoMill.x = player.x2;
                        autoMill.y = player.y2;
                    }
                } else if(autoGrindHotkey.toggle){
                    if(autoGrindHotkey.last > 3){
                        equips(40, 11);
                        place(player.items[5] || player.items[3], mouseAngle() + UTILS.toRad(50));
                        place(player.items[5] || player.items[3], mouseAngle() - UTILS.toRad(50));
                    } else autoGrindHotkey.last++;
                } else if (settings.autoPlacer) {
                    if (enemies.length && autoPlacer.last > 4) {
                        autoPlacer.last = 0;
                        let trap = enemy.lockMove && gameObjects.find(e => e.active && e.trap && e.owner.sid != enemy.sid && UTILS
                                                                      .getDistance(e.x, e.y, enemy.x2, enemy.y2) <= 50);
                        let dist = UTILS.getDistance(enemy.x2, enemy.y2, player.x2, player.y2);
                        let dir = UTILS.getDirection(enemy.x2, enemy.y2, player.x2, player.y2);
                        let spikeScale = items.list[player.items[2]].scale;
                        if (autoTrapBreaker) {
                            place(player.items[2], UTILS.getDirection(trap.x, trap.y, player.x2, player.y2) + Math.PI);
                        } else if (trap) {
                            let minRangeForSpike = 35 + 50 + items.list[player.items[2]].scale + (items.list[player.items[2]].placeOffset ||
                                                                                                  0);
                            let dist2 = UTILS.getDistance(trap.x, trap.y, player.x2, player.y2);
                            let dir2 = UTILS.getDistance(trap.x, trap.y, player.x2, player.y2);
                            if (dist <= minRangeForSpike) {
                                for (let i = dist <= 50 + 35 && player.items[4] == 15 && place(player.items[4], dir2) ? 50 + items.list[
                                    player.items[2]].scale : 0; i < 360; i += 30) {
                                    let angle = UTILS.toRad(i);
                                    place(player.items[2], dir2 + angle) && (i += 45);
                                }
                            } else if (dist <= minRangeForSpike + 35 + items.list[player.items[2]].scale) {
                                for (let i = 0; i < 35; i += 35 / 7) {
                                    let angle = UTILS.toRad(spikeScale + i);
                                    if (place(player.items[2], dir2 + angle)) break;
                                }
                                for (let i = 0; i < 35; i += 35 / 7) {
                                    let angle = UTILS.toRad(spikeScale + i);
                                    if (place(player.items[2], dir2 - angle)) break;
                                }
                                place(player.items[2], dir2);
                            }
                        } else if (player.items[4] == 15 && dist < 300) {
                            for (let i = 0; i < 360; i += 45) {
                                let angle = UTILS.toRad(i);
                                place(player.items[4], dir + angle) && (i += 50);
                            }
                        }
                    } else autoPlacer.last++;
                }

                autos.forEach(e => e.toggle != undefined && e.toDo.length && (e.toggle = false));
                autos.forEach(e => (e.toggle ?? true) && enemies.forEach(t => {
                    !anythingWorks() && e.try(t);
                }));
                enemies.forEach(t => {
                    autoKillerSpike.try(t);
                })
                let stopAnothers = false;
                for (let e of autos) {
                    if (e.toDo.length) {
                        e.toDo.pop()();
                        stopAnothers = true;
                        break;
                    }
                }
                if (stopAnothers) { } else {
                    !autoTrapBreaker && mouse.which == null && smtWorking && (smtWorking--, autoHit(false));
                    let usedAntiTrap = false;
                    if ((autoTrapBreaker || mouse.which != null) && !player.reloads[oldWeapon]) {
                        if (!smtWorking) {
                            smtWorking++;
                            if (autoTrapBreaker) {
                                if (settings.antiTrap) {
                                    let dir = UTILS.getDirection(trap.x, trap.y, player.x2, player.y2) - Math.PI * 1.5;
                                    if (enemies.length) {
                                        usedAntiTrap = true;
                                        if (UTILS.getDistance(enemy.x2, enemy.y2, player.x2, player.y2) < 300) {
                                            for (let i = 0; i < 180; i += 18) {
                                                let angle = UTILS.toRad(i);
                                                place(player.items[2], dir + angle) && (i += items.list[player.items[2]].scale / 2);
                                            }
                                        } else if (player.items[4] == 15) {
                                            for (let i = 0; i < 180; i += 18) {
                                                let angle = UTILS.toRad(i);
                                                place(player.items[4], dir + angle) && (i += 25);
                                            }
                                        }
                                    }
                                }
                            }
                            autoHit(true);
                        }
                        if (autoTrapBreaker || mouse.which == 2) {
                            let mode = autoTrapBreaker ? settings.autoTrapBreakerModes : "normal";
                            let activeMode = false;
                            mode == "offensive" ? (activeMode = enemies.find(e => UTILS.getAngleDist(
                                UTILS.getDirection(e.x2, e.y2, player.x2, player.y2),
                                UTILS.getDirection(trap.x, trap.y, player.x2, player.y2)
                            ) < Math.PI / 2.6 && UTILS.getDistance(e.x2, e.y2, player.x2, player.y2) <= items.weapons[player
                                                                                                                      .weapons[0]].range + 63)) : activeMode = true;
                            equips(autoTrapBreaker ? (settings.fullSoldierOnAutoTrapBreaker ? 6 : activeMode && mode == "offensive" ? skinConditions(7, 21, 40) : 40) : 40, 21);
                            choose((mode != "offensive" || !activeMode) && player.weapons[1] == 10 ? 10 : player.weapons[0], true);
                            watch(autoTrapBreaker ? UTILS.getDirection(trap.x, trap.y, player.x2, player.y2) : mouseAngle());
                        } else if (mouse.which == 0) {
                            equips(7, 21);
                            choose(player.weapons[0], true);
                            watch(enemies.length ? UTILS.getDirection(enemy.x2, enemy.y2, player.x2, player.y2) : mouseAngle());
                        } else if (mouse.which == 1) {
                            equips(21, 21);
                            choose(player.weapons[0], true);
                            watch(enemies.length ? UTILS.getDirection(enemy.x2, enemy.y2, player.x2, player.y2) : mouseAngle());
                        }
                    } else {
                        settings.autoWeaponCharger && ([player.weapons[1] ?? player.weapons[0], player.weapons[0]].every(e => {
                            if(player.reloads[e]) return choose(e, 1);
                            return false;
                        }));
                        if (auto.equiper.allowCount == 0) {
                            let autoCX = autoTrapBreaker || mouse.which != null;
                            let inRiver = player.y2 > 14400 / 2 - 724 / 2 && player.y2 < 14400 / 2 + 724 / 2;
                            let date;
                            let autoTrapBreakerMode = autoTrapBreaker ? settings.autoTrapBreakerModes : "normal";
                            let activeMode = false;
                            autoTrapBreakerMode == "defensive" && (activeMode = enemies.find(e => UTILS.getDistance(
                                e.x2, e.y2, player.x2, player.y2) <= items.weapons[e.weapons[0]].range + 63));
                            if (settings.autoShameReseter && player.shameCount > 0 && (tickCount - lastShameReset) % 5 == 0) {
                                equips(7, 13);
                            } else if(settings.autoEmp && gameObjects.find(e => e.id == 17 && e.owner.sid != player.sid && !alliancePlayers.includes(e.owner.sid) && UTILS.getDistance(e.x, e.y, player.x2, player.y2) <= 700)){
                                equips(22, autoCX ? 21 : 11);
                            } else if ((settings.autoDamager || autoTrapBreakerMode == "defensive" && activeMode) && enemies.length && enemies.find(e => !e.reloads[e.weaponIndex] &&
                                                                                                                                                    (date = Date.now() - window.pingTime - e.lastHit) && (!date || date > items.weapons[e.weaponIndex].speed * 2 || date > items.weapons[e.weaponIndex].speed &&
                  date < items.weapons[e.weaponIndex].speed + 1e3 / 9) &&
                                                                                                                                                    UTILS.getDistance(e.x2, e.y2, player.x2, player.y2) <= items.weapons[e.weaponIndex].range + 63)) {
                                equips(autoTrapBreakerMode == "defensive" && activeMode ? 26 : 11, 21);
                            } else if (settings.autoSoldier && enemies.length && UTILS.getDistance(enemy.x2, enemy.y2, player.x2, player
                                                                                                   .y2) < 300 && (!inRiver || settings.autoSoldierInRiver)) {
                                equips(6, autoCX ? 21 : 11);
                            } else if (settings.autoBiomeHat) {
                                if (player.y2 <= 2400) {
                                    equips(15, autoCX ? 21 : 11);
                                } else if (inRiver) {
                                    equips(31, autoCX ? 21 : 11);
                                } else equips(12, autoCX ? 21 : 11);
                            } else equips(12, autoCX ? 21 : 11);
                        }
                        if (!smtWorking && auto.watcher.allowCount == 0) {
                            watch(mouseAngle());
                        }
                    }
                }
            }

            function updateLeaderboard(datas) {
                leaderboardPlayers = [];
                for (let i = 0; i < datas.length;) {
                    let data = datas.slice(i, i + 3);
                    leaderboardPlayers.push({
                        sid: data[0],
                        name: data[1],
                        points: data[2]
                    });
                    i += 3;
                }
            }

            function loadGameObject(datas) {
                for (var i = 0; i < datas.length;) {
                    let data = datas.slice(i, i + 8);
                    objectManager.add(data[0], data[1], data[2], data[3], data[4], data[5], items.list[data[6]], true, (data[7] >= 0 ? {
                        sid: data[7],
                    } : null));
                    i += 8;
                }
            }

            function loadAI(datas) {
                for (let tmpObj of ais) {
                    tmpObj.forcePos = !tmpObj.visible;
                    tmpObj.visible = false;
                }
                if (datas) {
                    let tmpTime = Date.now();
                    for (let i = 0; i < datas.length;) {
                        let data = datas.slice(i, i + 7);
                        let tmpObj = getAI(data[0]);
                        if (tmpObj) {
                            tmpObj.index = data[1];
                            tmpObj.t1 = (tmpObj.t2 === undefined) ? tmpTime : tmpObj.t2;
                            tmpObj.t2 = tmpTime;
                            tmpObj.x1 = tmpObj.x;
                            tmpObj.y1 = tmpObj.y;
                            tmpObj.x2 = data[2];
                            tmpObj.y2 = data[3];
                            tmpObj.d1 = (tmpObj.d2 === undefined) ? data[4] : tmpObj.d2;
                            tmpObj.d2 = data[4];
                            let amount = data[5] - tmpObj.health;
                            tmpObj.lastBleed.amount = amount;
                            tmpObj.lastBleed.time = tmpTime - window.pingTime;
                            tmpObj.health = data[5];
                            tmpObj.dt = 0;
                            tmpObj.visible = true;
                        } else {
                            tmpObj = aiManager.spawn(data[2], data[3], data[4], data[1]);
                            tmpObj.x2 = tmpObj.x;
                            tmpObj.y2 = tmpObj.y;
                            tmpObj.d2 = tmpObj.dir;
                            tmpObj.health = data[5];
                            if (!aiManager.aiTypes[data[1]].name) tmpObj.name = config.cowNames[data[6]];
                            tmpObj.forcePos = true;
                            tmpObj.sid = data[0];
                            tmpObj.visible = true;
                        }
                        tmpObj.update(1e3 / 9);
                        i += 7;
                    }
                }
            }

            function animateAI(sid) {
                let tmpObj = getAI(sid);
            }

            function gatherAnimation(sid, didHit, index) {
                let tmpObj = getPlayer(sid);
                tmpObj.gather(index, didHit);
            }

            function wiggleGameObject(dir, sid) {
                let tmpObj = getObject(sid);
                if (tmpObj) {
                    tmpObj.lastWiggle = Date.now() - window.pingTime;
                    tmpObj.xWiggle += config.gatherWiggle * Math.cos(dir);
                    tmpObj.yWiggle += config.gatherWiggle * Math.sin(dir);
                }
            }

            function shootTurret(sid, dir) {
                let tmpObj = getObject(sid);
                if (tmpObj) {
                    tmpObj.shootCount = tmpObj.shootRate;
                    tmpObj.dir = dir;
                    tmpObj.xWiggle += config.gatherWiggle * Math.cos(dir + Math.PI);
                    tmpObj.yWiggle += config.gatherWiggle * Math.sin(dir + Math.PI);
                }
            }

            function updatePlayerValue(index, value, updateView) {
                if (player) {
                    player.addResource(index, value);
                }
            }
            var autoHeal;

            function updateHealth(sid, value) {
                let tmpObj = getPlayer(sid);
                if (tmpObj) {
                    let amount = value - tmpObj.health;
                    tmpObj.changeHealth(value);
                    if (player == tmpObj && amount == -5 + (tmpObj.tail?.healthRegen ? 3 : 0)) {
                        lastShameReset = tickCount;
                    }
                    if (tmpObj == player && value < 100) {
                        let doMaxHeal = function() {
                            clearInterval(autoHeal);
                            for (let i = 0; i < Math.ceil(Math.min(100 - value, 50) / items.list[player.items[0]].consume); i++) place(
                                player.items[0]);
                        }
                        if (settings.autoHeal) {
                            clearInterval(autoHeal);
                            autoHeal = setInterval(() => {
                                if (player.alive && player.health < 100) {
                                    if (Date.now() - window.pingTime - player.lastBleed.time > 120) {
                                        doMaxHeal();
                                    }
                                } else clearInterval(autoHeal);
                            }, 30);
                        }
                        if (player.shameCount < 6) {
                            let antiInsta
                            let bullDagger = new Array(4).fill(30).map((a, b) => a * config.weaponVariants[b].val);
                            let bullDagger_ai = enemies.filter(e => UTILS.getDistance(e.x2, e.y2, player.x2, player.y2) <= 300
                                                               && (e.weapons[1] == undefined || items.weapons[e.weapons[1]].projectile != undefined)
                                                               && e.weapons[0] == 7
                                                               && [7, e.weapons[1] ?? 7].every(a => {
                                if (e.reloads[a]) return false;
                                return true;
                            }) && !e.shootCount);
                            let sword_both = new Array(8).fill(35).map((a, b) => a * config.weaponVariants[b > 3 ? b - 4 : b].val * (b > 3 ? 1.5 : 1));
                            let sword_ai = enemies.filter(e => UTILS.getDistance(e.x2, e.y2, player.x2, player.y2) <= 300
                                                          && (e.weapons[1] == undefined || items.weapons[e.weapons[1]].projectile != undefined)
                                                          && e.weapons[0] == 3
                                                          && [3, e.weapons[1] ?? 3].every(a => {
                                if (e.reloads[a]) return false;
                                return true;
                            }));
                            let soldierBullSword = new Array(2).fill(35 * 1.5 * 0.75).map((a, b) => a * config.weaponVariants[b + 2].val);
                            let soldierBullSword_ai = sword_ai.filter(e => !e.shootCount);

                            let polearm_both = new Array(8).fill(45).map((a, b) => a * config.weaponVariants[b > 3 ? b - 4 : b].val * (b > 3 ? 1.5 : 1));
                            let polearm_ai = enemies.filter(e => UTILS.getDistance(e.x2, e.y2, player.x2, player.y2) <= 300
                                                            && (e.weapons[1] == undefined || items.weapons[e.weapons[1]].projectile != undefined)
                                                            && e.weapons[0] == 5
                                                            && [5, e.weapons[1] ?? 5].every(a => {
                                if (e.reloads[a]) return false;
                                return true;
                            }));

                            let soldierBullPolearm_both = new Array(4).fill(45 * .75 * 1.5).map((a, b) => a * config.weaponVariants[b].val);
                            let soldierBullPolearm_ai = polearm_ai.filter(e => !e.shootCount);

                            let bullKatana = new Array(4).fill(40 * 1.5).map((a, b) => a * config.weaponVariants[b].val);
                            let hammer_both = new Array(8).fill(10).map((a, b) => a * config.weaponVariants[b > 3 ? b - 4 : b].val * (b > 3 ? 1.5 : 1));
                            let hammer_ai = enemies.filter(e => UTILS.getDistance(e.x2, e.y2, player.x2, player.y2) <= 300
                                                           && [undefined, 10].includes(e.weapons[1])
                                                           && [0, 4, 5].includes(e.weapons[0])
                                                           && [e.weapons[0], 10 ?? e.weapons[0]].every(a => {
                                if (e.reloads[a]) return false;
                                return true;
                            }) && !e.shootCount);
                            let antiInstaWorked = false;
                            if (settings.antiInsta) {
                                if (bullDagger.includes(-amount) && bullDagger_ai.length) {
                                    doMaxHeal();
                                } else if (sword_both.includes(-amount) && (amount <= -35 * 1.5 ? sword_ai.length : soldierBullSword_ai.length)) {
                                    doMaxHeal();
                                } else if (soldierBullSword.includes(-amount) && soldierBullSword_ai.length) {
                                    doMaxHeal();
                                } else if (polearm_both.includes(-amount) && (amount <= -45 * 1.5 ? polearm_ai.length : soldierBullPolearm_ai.length)) {
                                    doMaxHeal();
                                } else if (soldierBullPolearm_both.includes(-amount) && soldierBullPolearm_ai.length) {
                                    doMaxHeal();
                                } else if ((bullKatana.includes(-amount) || hammer_both.includes(-amount) || amount == -25) && hammer_ai.length) {
                                    doMaxHeal();
                                }
                            }
                            if (!antiInstaWorked && value <= 50 && settings.antiLowHealth) {
                                doMaxHeal();
                            }
                        }
                    }
                }
            }

            function killPlayer() {
                player.kill();
                oldWeapon = 0;
                oldBuild = -1;
                smtWorking = 0;
                autoHitToggle = 0;
                auto.equiper.allowCount = 0;
                auto.watcher.allowCount = 0;
                autoPlacer.last = 0;
                autoGrindHotkey.toggle = 0;
                smtWorking = false;
                clearInterval(autoHeal);
            }

            function killObject(sid) {
                let tmpObj = getObject(sid);
                if (tmpObj) {
                    if (settings.autoReplacer && enemies.length && UTILS.getDistance(tmpObj.x, tmpObj.y, player.x2, player.y2) <= 200) {
                        let spike = items.list[player.items[2]];
                        let trap = items.list[15];
                        let dist = UTILS.getDistance(enemy.x2, enemy.y2, player.x2, player.y2);
                        let dir = UTILS.getDirection(enemy.x2, enemy.y2, player.x2, player.y2);
                        let ignoreStraight = false;
                        if (dist < 200) {
                            for (let i = 0; i < 90 - spike.scale; i += 5) {
                                let angle = spike.scale + UTILS.toRad(i);
                                if (place(player.items[2], dir + angle)) {
                                    break;
                                }
                            }
                            for (let i = 0; i < 90 - spike.scale; i += 5) {
                                let angle = spike.scale + UTILS.toRad(i);
                                if (place(player.items[2], dir - angle)) {
                                    break;
                                }
                            }
                            if(place(player.items[2], dir)) {
                            }
                        } else if (dist < 350 && player.items[4] == 15) {
                            for (let i = 0; i < 360; i += 10) {
                                let angle = UTILS.toRad(i);
                                place(player.items[4], angle) && (i += trap.scale);
                            }
                        }
                    }
                }
                objectManager.disableBySid(sid);
            }

            function killObjects(sid) {
                if (player) objectManager.removeAllItems(sid);
            }

            function updateItemCounts(index, value) {
                if (player) {
                    player.changeItemCount(index, value);
                }
            }

            function updateAge(xp, maxXP, age) {
                player.earnXP(xp);
            }

            function updateUpgrades(points, age) { }

            function updateItems(datas, wpn) {
                if (datas) {
                    if (wpn) player.weapons = datas;
                    else player.items = datas;
                    if (wpn) {
                        oldWeapon = player.weapons[Number(oldWeapon > 8)];
                        oldWeapon == undefined && (oldWeapon = player.weapons[0]);
                    }
                }
            }

            function addProjectile(x, y, dir, range, speed, indx, layer, sid) {
                projectileManager.addProjectile(x, y, dir, range, speed, indx, null, null, layer, sid);
            }

            function removeProjectile(sid, range) {
                let tmpObj = projectiles.find(e => e.sid == sid);
                tmpObj && (tmpObj.range = range);
            }

            function serverShutdownNotice(countdown) {
                if (countdown < 0) return;

                var minutes = Math.floor(countdown / 60);
                var seconds = countdown % 60;
                seconds = ("0" + seconds).slice(-2);
            }

            function addAlliance(datas) {
                alliances.push(datas);
            }

            function deleteAlliance(sid) {
                for (var i = alliances.length - 1; i >= 0; i--) {
                    if (alliances[i].sid == sid) alliances.splice(i, 1);
                }
            }

            function allianceNotification(sid, name) {
                allianceNotifications.push({
                    sid: sid,
                    name: name
                });
            }

            function setPlayerTeam(team, isOwner) {
                if (player) {
                    player.team = team;
                    player.isOwner = isOwner;
                }
            }

            function setAlliancePlayers(datas) {
                alliancePlayers = datas;
            }

            function updateStoreItems(type, id, index) {
                if (index) {
                    if (!type) player.tails[id] = 1;
                    else player.tailIndex = id;
                } else {
                    if (!type) player.skins[id] = 1;
                    else player.skinIndex = id;
                }
            }

            function receiveChat(sid, message) {
                let tmpObj = getPlayer(sid);
                if (tmpObj != player && settings.mirrorChat) {
                    chat(message);
                }
            }

            function updateMinimap(datas) {
                minimapData = datas;
            }

            function showText(x, y, value, type) { }

            function pingMap(x, y) {
                for (var i = 0; i < mapPings.length; ++i) {
                    if (!mapPings[i].active) {
                        tmpPing = mapPings[i];
                        break;
                    }
                }
                if (!tmpPing) {
                    tmpPing = new MapPing();
                    mapPings.push(tmpPing);
                }
                tmpPing.init(x, y);
            }

            function pingSocketResponse() {
                console.log("got ping");
            }

            // GET ITEM SPRITE:
            var itemSprites = [];

            function getItemSprite(obj, asIcon) {
                var tmpSprite = itemSprites[obj.id];
                if (!tmpSprite || asIcon) {
                    var tmpCanvas = document.createElement('canvas');
                    tmpCanvas.width = tmpCanvas.height = (obj.scale * 2.5) + outlineWidth +
                        (items.list[obj.id]?.spritePadding || 0);
                    var tmpContext = tmpCanvas.getContext('2d');
                    tmpContext.translate((tmpCanvas.width / 2), (tmpCanvas.height / 2));
                    tmpContext.rotate(asIcon ? 0 : (Math.PI / 2));
                    tmpContext.strokeStyle = outlineColor;
                    tmpContext.lineWidth = outlineWidth * (asIcon ? (tmpCanvas.width / 81) : 1);
                    if (obj.name == "apple") {
                        tmpContext.fillStyle = "#c15555";
                        renderCircle(0, 0, obj.scale, tmpContext);
                        tmpContext.fillStyle = "#89a54c";
                        var leafDir = -(Math.PI / 2);
                        renderLeaf(obj.scale * Math.cos(leafDir), obj.scale * Math.sin(leafDir),
                                   25, leafDir + Math.PI / 2, tmpContext);
                    } else if (obj.name == "cookie") {
                        tmpContext.fillStyle = "#cca861";
                        renderCircle(0, 0, obj.scale, tmpContext);
                        tmpContext.fillStyle = "#937c4b";
                        var chips = 4;
                        var rotVal = Math.PI * 2 / chips;
                        var tmpRange;
                        for (var i = 0; i < chips; ++i) {
                            tmpRange = UTILS.randInt(obj.scale / 2.5, obj.scale / 1.7);
                            renderCircle(tmpRange * Math.cos(rotVal * i), tmpRange * Math.sin(rotVal * i),
                                         UTILS.randInt(4, 5), tmpContext, true);
                        }
                    } else if (obj.name == "cheese") {
                        tmpContext.fillStyle = "#f4f3ac";
                        renderCircle(0, 0, obj.scale, tmpContext);
                        tmpContext.fillStyle = "#c3c28b";
                        let chips = 4;
                        let rotVal = Math.PI * 2 / chips;
                        let tmpRange;
                        for (let i = 0; i < chips; ++i) {
                            tmpRange = UTILS.randInt(obj.scale / 2.5, obj.scale / 1.7);
                            renderCircle(tmpRange * Math.cos(rotVal * i), tmpRange * Math.sin(rotVal * i),
                                         UTILS.randInt(4, 5), tmpContext, true);
                        }
                    } else if (obj.name == "wood wall" || obj.name == "stone wall" || obj.name == "castle wall") {
                        tmpContext.fillStyle = (obj.name == "castle wall") ? "#83898e" : (obj.name == "wood wall") ?
                            "#a5974c" : "#939393";
                        var sides = (obj.name == "castle wall") ? 4 : 3;
                        renderStar(tmpContext, sides, obj.scale * 1.1, obj.scale * 1.1);
                        tmpContext.fill();
                        tmpContext.stroke();
                        tmpContext.fillStyle = (obj.name == "castle wall") ? "#9da4aa" : (obj.name == "wood wall") ?
                            "#c9b758" : "#bcbcbc";
                        renderStar(tmpContext, sides, obj.scale * 0.65, obj.scale * 0.65);
                        tmpContext.fill();
                    } else if (obj.name == "spikes" || obj.name == "greater spikes" || obj.name == "poison spikes" ||
                               obj.name == "spinning spikes") {
                        tmpContext.fillStyle = (obj.name == "poison spikes") ? "#7b935d" : "#939393";
                        var tmpScale = (obj.scale * 0.6);
                        renderStar(tmpContext, (obj.name == "spikes") ? 5 : 6, obj.scale, tmpScale);
                        tmpContext.fill();
                        tmpContext.stroke();
                        tmpContext.fillStyle = "#a5974c";
                        renderCircle(0, 0, tmpScale, tmpContext);
                        tmpContext.fillStyle = "#c9b758";
                        renderCircle(0, 0, tmpScale / 2, tmpContext, true);
                    } else if (obj.name == "windmill" || obj.name == "faster windmill" || obj.name == "power mill") {
                        tmpContext.fillStyle = "#a5974c";
                        renderCircle(0, 0, obj.scale, tmpContext);
                        tmpContext.fillStyle = "#c9b758";
                        renderRectCircle(0, 0, obj.scale * 1.5, 29, 4, tmpContext);
                        tmpContext.fillStyle = "#a5974c";
                        renderCircle(0, 0, obj.scale * 0.5, tmpContext);
                    } else if (obj.name == "mine") {
                        tmpContext.fillStyle = "#939393";
                        renderStar(tmpContext, 3, obj.scale, obj.scale);
                        tmpContext.fill();
                        tmpContext.stroke();
                        tmpContext.fillStyle = "#bcbcbc";
                        renderStar(tmpContext, 3, obj.scale * 0.55, obj.scale * 0.65);
                        tmpContext.fill();
                    } else if (obj.name == "sapling") {
                        for (let i = 0; i < 2; ++i) {
                            let tmpScale = obj.scale * (!i ? 1 : 0.5);
                            renderStar(tmpContext, 7, tmpScale, tmpScale * 0.7);
                            tmpContext.fillStyle = (!i ? "#9ebf57" : "#b4db62");
                            tmpContext.fill();
                            if (!i) tmpContext.stroke();
                        }
                    } else if (obj.name == "pit trap") {
                        tmpContext.fillStyle = "#a5974c";
                        renderStar(tmpContext, 3, obj.scale * 1.1, obj.scale * 1.1);
                        tmpContext.fill();
                        tmpContext.stroke();
                        tmpContext.fillStyle = outlineColor;
                        renderStar(tmpContext, 3, obj.scale * 0.65, obj.scale * 0.65);
                        tmpContext.fill();
                    } else if (obj.name == "boost pad") {
                        tmpContext.fillStyle = "#7e7f82";
                        renderRect(0, 0, obj.scale * 2, obj.scale * 2, tmpContext);
                        tmpContext.fill();
                        tmpContext.stroke();
                        tmpContext.fillStyle = "#dbd97d";
                        renderTriangle(obj.scale * 1, tmpContext);
                    } else if (obj.name == "turret") {
                        tmpContext.fillStyle = "#a5974c";
                        renderCircle(0, 0, obj.scale, tmpContext);
                        tmpContext.fill();
                        tmpContext.stroke();
                        tmpContext.fillStyle = "#939393";
                        var tmpLen = 50;
                        renderRect(0, -tmpLen / 2, obj.scale * 0.9, tmpLen, tmpContext);
                        renderCircle(0, 0, obj.scale * 0.6, tmpContext);
                        tmpContext.fill();
                        tmpContext.stroke();
                    } else if (obj.name == "platform") {
                        tmpContext.fillStyle = "#cebd5f";
                        var tmpCount = 4;
                        var tmpS = obj.scale * 2;
                        var tmpW = tmpS / tmpCount;
                        var tmpX = -(obj.scale / 2);
                        for (let i = 0; i < tmpCount; ++i) {
                            renderRect(tmpX - (tmpW / 2), 0, tmpW, obj.scale * 2, tmpContext);
                            tmpContext.fill();
                            tmpContext.stroke();
                            tmpX += tmpS / tmpCount;
                        }
                    } else if (obj.name == "healing pad") {
                        tmpContext.fillStyle = "#7e7f82";
                        renderRect(0, 0, obj.scale * 2, obj.scale * 2, tmpContext);
                        tmpContext.fill();
                        tmpContext.stroke();
                        tmpContext.fillStyle = "#db6e6e";
                        renderRectCircle(0, 0, obj.scale * 0.65, 20, 4, tmpContext, true);
                    } else if (obj.name == "spawn pad") {
                        tmpContext.fillStyle = "#7e7f82";
                        renderRect(0, 0, obj.scale * 2, obj.scale * 2, tmpContext);
                        tmpContext.fill();
                        tmpContext.stroke();
                        tmpContext.fillStyle = "#71aad6";
                        renderCircle(0, 0, obj.scale * 0.6, tmpContext);
                    } else if (obj.name == "blocker") {
                        tmpContext.fillStyle = "#7e7f82";
                        renderCircle(0, 0, obj.scale, tmpContext);
                        tmpContext.fill();
                        tmpContext.stroke();
                        tmpContext.rotate(Math.PI / 4);
                        tmpContext.fillStyle = "#db6e6e";
                        renderRectCircle(0, 0, obj.scale * 0.65, 20, 4, tmpContext, true);
                    } else if (obj.name == "teleporter") {
                        tmpContext.fillStyle = "#7e7f82";
                        renderCircle(0, 0, obj.scale, tmpContext);
                        tmpContext.fill();
                        tmpContext.stroke();
                        tmpContext.rotate(Math.PI / 4);
                        tmpContext.fillStyle = "#d76edb";
                        renderCircle(0, 0, obj.scale * 0.5, tmpContext, true);
                    }
                    tmpSprite = tmpCanvas;
                    if (!asIcon) itemSprites[obj.id] = tmpSprite;
                }
                return tmpSprite;
            }
            // RENDER LEAF:
            function renderLeaf(x, y, l, r, ctxt) {
                var endX = x + (l * Math.cos(r));
                var endY = y + (l * Math.sin(r));
                var width = l * 0.4;
                ctxt.moveTo(x, y);
                ctxt.beginPath();
                ctxt.quadraticCurveTo(((x + endX) / 2) + (width * Math.cos(r + Math.PI / 2)),
                                      ((y + endY) / 2) + (width * Math.sin(r + Math.PI / 2)), endX, endY);
                ctxt.quadraticCurveTo(((x + endX) / 2) - (width * Math.cos(r + Math.PI / 2)),
                                      ((y + endY) / 2) - (width * Math.sin(r + Math.PI / 2)), x, y);
                ctxt.closePath();
                ctxt.fill();
                ctxt.stroke();
            }

            // RENDER CIRCLE:
            function renderCircle(x, y, scale, tmpContext, dontStroke, dontFill) {
                tmpContext = tmpContext || mainContext;
                tmpContext.beginPath();
                tmpContext.arc(x, y, scale, 0, 2 * Math.PI);
                if (!dontFill) tmpContext.fill();
                if (!dontStroke) tmpContext.stroke();
            }

            // RENDER STAR SHAPE:
            function renderStar(ctxt, spikes, outer, inner) {
                var rot = Math.PI / 2 * 3;
                var x, y;
                var step = Math.PI / spikes;
                ctxt.beginPath();
                ctxt.moveTo(0, -outer);
                for (var i = 0; i < spikes; i++) {
                    x = Math.cos(rot) * outer;
                    y = Math.sin(rot) * outer;
                    ctxt.lineTo(x, y);
                    rot += step;
                    x = Math.cos(rot) * inner;
                    y = Math.sin(rot) * inner;
                    ctxt.lineTo(x, y);
                    rot += step;
                }
                ctxt.lineTo(0, -outer);
                ctxt.closePath();
            }

            // RENDER RECTANGLE:
            function renderRect(x, y, w, h, ctxt, stroke) {
                ctxt.fillRect(x - (w / 2), y - (h / 2), w, h);
                !stroke && ctxt.strokeRect(x - (w / 2), y - (h / 2), w, h);
            }

            // RENDER RECTCIRCLE:
            function renderRectCircle(x, y, s, sw, seg, ctxt, stroke) {
                ctxt.save();
                ctxt.translate(x, y);
                seg = Math.ceil(seg / 2);
                for (var i = 0; i < seg; i++) {
                    renderRect(0, 0, s * 2, sw, ctxt, stroke);
                    ctxt.rotate(Math.PI / seg);
                }
                ctxt.restore();
            }

            // RENDER BLOB:
            function renderBlob(ctxt, spikes, outer, inner) {
                var rot = Math.PI / 2 * 3;
                var x, y;
                var step = Math.PI / spikes;
                var tmpOuter;
                ctxt.beginPath();
                ctxt.moveTo(0, -inner);
                for (var i = 0; i < spikes; i++) {
                    tmpOuter = UTILS.randInt(outer + 0.9, outer * 1.2);
                    ctxt.quadraticCurveTo(Math.cos(rot + step) * tmpOuter, Math.sin(rot + step) * tmpOuter,
                                          Math.cos(rot + (step * 2)) * inner, Math.sin(rot + (step * 2)) * inner);
                    rot += step * 2;
                }
                ctxt.lineTo(0, -inner);
                ctxt.closePath();
            }

            // RENDER TRIANGLE:
            function renderTriangle(s, ctx) {
                ctx = ctx || mainContext;
                var h = s * (Math.sqrt(3) / 2);
                ctx.beginPath();
                ctx.moveTo(0, -h / 2);
                ctx.lineTo(-s / 2, h / 2);
                ctx.lineTo(s / 2, h / 2);
                ctx.lineTo(0, -h / 2);
                ctx.fill();
                ctx.closePath();
            }
            CanvasRenderingContext2D.prototype.drawIMG = function(image, x, y, width, height, direction = 0, borderRadius = 0) {
                let src = document.createElement("img");
                src.src = image;
                return (
                    this.save(),
                    this.translate(x, y),
                    this.rotate(direction),
                    this.beginPath(),
                    this.moveTo(-width / 2 + borderRadius, -height / 2),
                    this.lineTo(-width / 2 + width - borderRadius, -height / 2),
                    this.quadraticCurveTo(-width / 2 + width, -height / 2, -width / 2 + width, -height / 2 + borderRadius),
                    this.lineTo(-width / 2 + width, -height / 2 + height - borderRadius),
                    this.quadraticCurveTo(-width / 2 + width, -height / 2 + height, -width / 2 + width - borderRadius, -height / 2 +
                                          height),
                    this.lineTo(-width / 2 + borderRadius, -height / 2 + height),
                    this.quadraticCurveTo(-width / 2, -height / 2 + height, -width / 2, -height / 2 + height - borderRadius),
                    this.lineTo(-width / 2, -height / 2 + borderRadius),
                    this.quadraticCurveTo(-width / 2, -height / 2, -width / 2 + borderRadius, -height / 2),
                    this.closePath(),
                    this.clip(),
                    this.drawImage(src, -width / 2, -height / 2, width, height),
                    this.restore()
                )
            }

            function updateScript() {
                if (player) {
                    var tmpDist = UTILS.getDistance(camX, camY, player.x, player.y);
                    var tmpDir = UTILS.getDirection(player.x, player.y, camX, camY);
                    var camSpd = Math.min(tmpDist * 0.01 * delta, tmpDist);
                    if (tmpDist > 0.05) {
                        camX += camSpd * Math.cos(tmpDir);
                        camY += camSpd * Math.sin(tmpDir);
                    } else {
                        camX = player.x;
                        camY = player.y;
                    }
                } else {
                    camX = config.mapScale / 2;
                    camY = config.mapScale / 2;
                }

                // INTERPOLATE PLAYERS AND AI:
                var lastTime = now - (1000 / config.serverUpdateRate);
                let tmpDiff;
                for (var i = 0; i < players.length + ais.length; ++i) {
                    tmpObj = players[i] || ais[i - players.length];
                    if (tmpObj && tmpObj.visible) {
                        if (tmpObj.forcePos) {
                            tmpObj.x = tmpObj.x2;
                            tmpObj.y = tmpObj.y2;
                            tmpObj.dir = tmpObj.d2;
                        } else {
                            var total = tmpObj.t2 - tmpObj.t1;
                            var fraction = lastTime - tmpObj.t1;
                            var ratio = (fraction / total);
                            var rate = 170;
                            tmpObj.dt += delta;
                            var tmpRate = Math.min(1.7, tmpObj.dt / rate);
                            let tmpDiff = (tmpObj.x2 - tmpObj.x1);
                            tmpObj.x = tmpObj.x1 + (tmpDiff * tmpRate);
                            tmpDiff = (tmpObj.y2 - tmpObj.y1);
                            tmpObj.y = tmpObj.y1 + (tmpDiff * tmpRate);
                            tmpObj.dir = Math.lerpAngle(tmpObj.d2, tmpObj.d1, Math.min(1.2, ratio));
                        }
                    }
                }

                // RENDER CORDS:
                var xOffset = camX - (maxScreenWidth / 2);
                var yOffset = camY - (maxScreenHeight / 2);

                /*for (let tmpObj of gameObjects) {
          if (tmpObj.active) {
            if (tmpObj.health != undefined) {
              let tmpText = Math.round(tmpObj.health);
              mainContext.font = "20px Hammersmith One";
              mainContext.fillStyle = tmpObj.owner.sid == playerSID ? "#8ecc51" : "#cc5151";
              mainContext.strokeStyle = darkOutlineColor;
              mainContext.textBaseline = "middle";
              mainContext.textAlign = "center";
              mainContext.lineWidth = 8;
              mainContext.lineJoin = "round";
              mainContext.strokeText(tmpText, tmpObj.x - xOffset, tmpObj.y - yOffset);
              mainContext.fillText(tmpText, tmpObj.x - xOffset, tmpObj.y - yOffset);

              if(tmpObj.id == 17){
    mainContext.save();
    mainContext.globalAlpha = 0.6;
    mainContext.beginPath();
    mainContext.strokeStyle = tmpObj.owner.sid == player.sid ? "#8ecc51" : "#cc5151";
    mainContext.lineWidth = 3;
    mainContext.arc(tmpObj.x - xOffset, tmpObj.y - yOffset, 700, 0, Math.PI*2);
    mainContext.stroke();
    mainContext.restore();
}
            }
          }
        }*/
                for (let tmpObj of risklyAreas) {
                    mainContext.save();
                    mainContext.beginPath();
                    mainContext.filter = "blur(2px)";
                    mainContext.fillStyle = "red";
                    mainContext.arc(tmpObj.x - xOffset, tmpObj.y - yOffset, 10, 0, Math.PI * 2);
                    mainContext.fill();
                    mainContext.restore();
                }
                for (let tmpObj of players) {
                    if (tmpObj.visible) {
                        let tmpText = (tmpObj.team ? "[" + tmpObj.team + "] " : "") + (tmpObj.name || "");
                        mainContext.font = "32px Hammersmith One";
                        mainContext.fillStyle = "red";
                        mainContext.beginPath();
                        mainContext.strokeStyle = darkOutlineColor;
                        mainContext.beginPath();
                        mainContext.textBaseline = "middle";
                        mainContext.textAlign = "center";
                        mainContext.lineWidth = 8;
                        mainContext.lineJoin = "round";
                        mainContext.strokeText(
                            tmpObj.shameCount,
                            tmpObj.x - xOffset + mainContext.measureText(tmpText).width / 2 + 32,
                            tmpObj.y - yOffset - config.nameY - tmpObj.scale,
                        );
                        mainContext.fillText(
                            tmpObj.shameCount,
                            tmpObj.x - xOffset + mainContext.measureText(tmpText).width / 2 + 32,
                            tmpObj.y - yOffset - config.nameY - tmpObj.scale,
                        );
                        let tmpWidth = config.healthBarWidth;
                        let tmpPad = config.healthBarPad;

                        // PRIMARY RELOAD PAD:
                        mainContext.fillStyle = darkOutlineColor;
                        mainContext.roundRect(tmpObj.x - xOffset - tmpWidth - tmpPad,
                                              (tmpObj.y - yOffset + tmpObj.scale) + config.nameY - 17 + tmpPad, tmpWidth +
                                              tmpPad * 2, 17, 8);
                        mainContext.fill();

                        // PRIMARY RELOAD BAR:
                        mainContext.fillStyle = tmpObj.reloads[tmpObj.weapons[0]] ?
                            `hsl(${200 * ((items.weapons[tmpObj.weapons[0]].speed - tmpObj.reloads[tmpObj.weapons[0]]) / items.weapons[tmpObj.weapons[0]].speed) + 153}, 64%, 68%)` :
                        "#CC8751";
                        mainContext.roundRect(tmpObj.x - xOffset - tmpWidth,
                                              (tmpObj.y - yOffset + tmpObj.scale) + config.nameY + tmpPad * 2 - 17,
                                              tmpWidth - tmpWidth * (tmpObj.reloads[tmpObj.weapons[0]] / items.weapons[tmpObj.weapons[0]].speed), 17 -
                                              tmpPad * 2, 7);
                        mainContext.fill();

                        // SECONDARY RELOAD PAD:
                        mainContext.fillStyle = darkOutlineColor;
                        mainContext.roundRect(tmpObj.x - xOffset - tmpPad,
                                              (tmpObj.y - yOffset + tmpObj.scale) + config.nameY - 17 + tmpPad, tmpWidth +
                                              tmpPad * 2, 17, 8);
                        mainContext.fill();

                        // SECONDARY RELOAD BAR:
                        mainContext.fillStyle = tmpObj.weapons[1] && tmpObj.reloads[tmpObj.weapons[1]] ?
                            `hsl(${200 * ((items.weapons[tmpObj.weapons[1]].speed - tmpObj.reloads[tmpObj.weapons[1]]) / items.weapons[tmpObj.weapons[1]].speed) + 153}, 64%, 68%)` :
                        "#CC8751";
                        mainContext.roundRect(tmpObj.x - xOffset,
                                              (tmpObj.y - yOffset + tmpObj.scale) + config.nameY + tmpPad * 2 - 17,
                                              (tmpObj.weapons[1] ? tmpWidth - tmpWidth * (tmpObj.reloads[tmpObj.weapons[1]] / items.weapons[tmpObj
                                                                                                                                            .weapons[1]].speed) : tmpWidth), 17 - tmpPad * 2, 7);
                        mainContext.fill();

                        let underText = `[${Number(tmpObj.shootCount == 0)}]`;
                        mainContext.font = "15px Hammersmith One";
                        mainContext.fillStyle = "#fff";
                        mainContext.strokeStyle = darkOutlineColor;
                        mainContext.textBaseline = "middle";
                        mainContext.textAlign = "center";
                        mainContext.lineWidth = 7;
                        mainContext.lineJoin = "round";
                        mainContext.strokeText(underText, tmpObj.x - xOffset, (tmpObj.y - yOffset + tmpObj.scale) + config.nameY + 15 *
                                               1.5 + 5);
                        mainContext.fillText(underText, tmpObj.x - xOffset, (tmpObj.y - yOffset + tmpObj.scale) + config.nameY + 15 * 1.5 +
                                             5);
                        for (let each of Object.values(autoImg)) {
                            if (each.image.loaded && tmpObj.sid == each.target) {
                                mainContext.drawImage(each.image, tmpObj.x - xOffset - 35, tmpObj.y - yOffset - 35, 70, 70);
                            }
                        }
                        if (tmpObj != player && (!tmpObj.team || tmpObj.team != player.team)) {
                            if (manualImg.enemyRadar.image.loaded) {
                                let dir = UTILS.getDirection(tmpObj.x, tmpObj.y, player.x, player.y);
                                let dist = UTILS.getDistance(tmpObj.x, tmpObj.y, player.x, player.y);
                                //1248
                                mainContext.globalAlpha = dist < 70 ? 0 : Math.max(0, 1 - 700 / dist / 2);
                                mainContext.drawIMG(manualImg.enemyRadar.image.src,
                                                    player.x - xOffset + Math.cos(dir) * dist / 2,
                                                    player.y - yOffset + Math.sin(dir) * dist / 2,
                                                    30,
                                                    30,
                                                    dir + Math.PI / 2,
                                                    0);
                                mainContext.globalAlpha = 1;
                            }
                        }
                    }
                }
            }

            function doUpdate() {
                now = Date.now();
                delta = now - lastUpdate;
                lastUpdate = now;
                updateScript();
                window.requestAnimFrame(doUpdate);
            };
            doUpdate();
        };
    }),
});
document.addEventListener('DOMContentLoaded', function() {
    __webpack_require__("./script/src/js/app.js").run();
}, false);
